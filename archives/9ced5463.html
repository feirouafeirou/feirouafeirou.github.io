<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/astronaut32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/astronaut16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="fonts.googleapis.com/css?family=EB Garamond:300,300italic,400,400italic,700,700italic|Cinzel Decorative:300,300italic,400,400italic,700,700italic|Noto Serif SC:300,300italic,400,400italic,700,700italic|Source Code Pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"fat_fat_where_are_you.gitee.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":false,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

<link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@500&display=swap" rel="stylesheet">
  <meta name="description" content="考研数据结构代码整理">
<meta property="og:type" content="article">
<meta property="og:title" content="考研数据结构代码整理">
<meta property="og:url" content="http://fat_fat_where_are_you.gitee.io/archives/9ced5463.html">
<meta property="og:site_name" content="肥肉啊肥肉你在哪">
<meta property="og:description" content="考研数据结构代码整理">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://fat_fat_where_are_you.gitee.io/archives/9ced5463/20210813141715940.png">
<meta property="og:image" content="http://fat_fat_where_are_you.gitee.io/archives/9ced5463/1454315049-0.gif">
<meta property="og:image" content="http://fat_fat_where_are_you.gitee.io/archives/9ced5463/1454311B6-1.gif">
<meta property="og:image" content="http://fat_fat_where_are_you.gitee.io/archives/9ced5463/145431BB-2.gif">
<meta property="og:image" content="http://fat_fat_where_are_you.gitee.io/archives/9ced5463/1454314421-3.gif">
<meta property="og:image" content="http://fat_fat_where_are_you.gitee.io/archives/9ced5463/1454315601-4.gif">
<meta property="og:image" content="http://fat_fat_where_are_you.gitee.io/archives/9ced5463/145431L19-5.gif">
<meta property="og:image" content="http://fat_fat_where_are_you.gitee.io/archives/9ced5463/1454313005-6.gif">
<meta property="og:image" content="http://fat_fat_where_are_you.gitee.io/archives/9ced5463/20210813141738863-1633050039218.png">
<meta property="og:image" content="http://fat_fat_where_are_you.gitee.io/archives/9ced5463/145G46133-0.gif">
<meta property="og:image" content="http://fat_fat_where_are_you.gitee.io/archives/9ced5463/145G44143-1.gif">
<meta property="og:image" content="http://fat_fat_where_are_you.gitee.io/archives/9ced5463/145G41F4-2.gif">
<meta property="og:image" content="http://fat_fat_where_are_you.gitee.io/archives/9ced5463/145G4D41-3.gif">
<meta property="og:image" content="http://fat_fat_where_are_you.gitee.io/archives/9ced5463/145G44336-4.gif">
<meta property="og:image" content="http://fat_fat_where_are_you.gitee.io/archives/9ced5463/145G4CN-5.gif">
<meta property="og:image" content="http://fat_fat_where_are_you.gitee.io/archives/9ced5463/145G44357-6.gif">
<meta property="og:image" content="http://fat_fat_where_are_you.gitee.io/archives/9ced5463/145G45057-7.gif">
<meta property="og:image" content="http://fat_fat_where_are_you.gitee.io/archives/9ced5463/145G4M94-8.gif">
<meta property="og:image" content="http://fat_fat_where_are_you.gitee.io/archives/9ced5463/20210813141818125-1633050039220.png">
<meta property="og:image" content="http://fat_fat_where_are_you.gitee.io/archives/9ced5463/2021081314182741-1633050039221.png">
<meta property="og:image" content="http://fat_fat_where_are_you.gitee.io/archives/9ced5463/image-20210929101337540.png">
<meta property="og:image" content="http://fat_fat_where_are_you.gitee.io/archives/9ced5463/v2-cdd360483874245e65eb96c8374b598c_720w.jpg">
<meta property="og:image" content="http://fat_fat_where_are_you.gitee.io/archives/9ced5463/v2-d29190c3a51249cbbc0be5ed8ebb7c13_720w.jpg">
<meta property="og:image" content="http://fat_fat_where_are_you.gitee.io/archives/9ced5463/20210813141902545.png">
<meta property="og:image" content="http://fat_fat_where_are_you.gitee.io/archives/9ced5463/1502393Y3-0.gif">
<meta property="og:image" content="http://fat_fat_where_are_you.gitee.io/archives/9ced5463/image-20211125181038341.png">
<meta property="og:image" content="http://fat_fat_where_are_you.gitee.io/archives/9ced5463/image-20211125181230348.png">
<meta property="og:image" content="http://fat_fat_where_are_you.gitee.io/archives/9ced5463/image-20211125181445471.png">
<meta property="og:image" content="http://fat_fat_where_are_you.gitee.io/archives/9ced5463/image-20211125181538426.png">
<meta property="og:image" content="http://fat_fat_where_are_you.gitee.io/archives/9ced5463/image-20211125181738896.png">
<meta property="og:image" content="http://fat_fat_where_are_you.gitee.io/archives/9ced5463/image-20211125181840892.png">
<meta property="og:image" content="http://fat_fat_where_are_you.gitee.io/archives/9ced5463/image-20211125182032635.png">
<meta property="og:image" content="http://fat_fat_where_are_you.gitee.io/archives/9ced5463/image-20211125182138691.png">
<meta property="og:image" content="http://fat_fat_where_are_you.gitee.io/archives/9ced5463/image-20211125182314634.png">
<meta property="article:published_time" content="2021-08-17T07:24:43.000Z">
<meta property="article:modified_time" content="2021-08-17T07:24:43.000Z">
<meta property="article:author" content="肥肉啊肥肉你在哪">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://fat_fat_where_are_you.gitee.io/archives/9ced5463/20210813141715940.png">

<link rel="canonical" href="http://fat_fat_where_are_you.gitee.io/archives/9ced5463.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<link rel="stylesheet" type="text/css" href="/css/injector/main.css"><link rel="preload" as="style" href="/css/injector/light.css"><link rel="preload" as="style" href="/css/injector/dark.css">
  <title>考研数据结构代码整理 | 肥肉啊肥肉你在哪</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

  <script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css">

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">肥肉啊肥肉你在哪</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-movies">

    <a href="/movies/" rel="section"><i class="fa fa-film fa-fw"></i>观影</a>

  </li>
        <li class="menu-item menu-item-books">

    <a href="/books/" rel="section"><i class="fa fa-book fa-fw"></i>阅读</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://fat_fat_where_are_you.gitee.io/archives/9ced5463.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.gif">
      <meta itemprop="name" content="肥肉啊肥肉你在哪">
      <meta itemprop="description" content>
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="肥肉啊肥肉你在哪">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          考研数据结构代码整理
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-17 15:24:43" itemprop="dateCreated datePublished" datetime="2021-08-17T15:24:43+08:00">2021-08-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%80%83%E7%A0%94/" itemprop="url" rel="index"><span itemprop="name">考研</span></a>
                </span>
            </span>

          
          
          <br>
            <span id="/archives/9ced5463.html" class="post-meta-item leancloud_visitors" data-flag-title="考研数据结构代码整理" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/archives/9ced5463.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/archives/9ced5463.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>37k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>34 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="考研数据结构代码整理"><a href="# 考研数据结构代码整理" class="headerlink" title="考研数据结构代码整理"></a>考研数据结构代码整理</h1><span id="more"></span>

<h2 id="1- 线性表的结构体定义"><a href="#1- 线性表的结构体定义" class="headerlink" title="1. 线性表的结构体定义"></a>1. 线性表的结构体定义</h2><h3 id="1-1）顺序表的结构体定义"><a href="#1-1）顺序表的结构体定义" class="headerlink" title="1.1）顺序表的结构体定义"></a>1.1）顺序表的结构体定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> data[maxSize];   <span class="comment">// 存放顺序表元素的数组</span></span><br><span class="line">	<span class="keyword">int</span> length;     <span class="comment">// 存放顺序表的长度</span></span><br><span class="line">&#125;Sqlist;</span><br></pre></td></tr></table></figure>

<h3 id="1-2）考试中顺序表定义简写法"><a href="#1-2）考试中顺序表定义简写法" class="headerlink" title="1.2）考试中顺序表定义简写法"></a>1.2）考试中顺序表定义简写法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> A[maxSize];</span><br><span class="line">    <span class="keyword">int</span> n;</span><br></pre></td></tr></table></figure>

<h3 id="1-3）单链表的结构体定义"><a href="#1-3）单链表的结构体定义" class="headerlink" title="1.3）单链表的结构体定义"></a>1.3）单链表的结构体定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> data;   <span class="comment">// 数据域</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span>   <span class="comment">// 指向后继结点的指针</span></span><br><span class="line">&#125;LNode;</span><br></pre></td></tr></table></figure>

<h3 id="1-4）双链表结构体定义"><a href="#1-4）双链表结构体定义" class="headerlink" title="1.4）双链表结构体定义"></a>1.4）双链表结构体定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DLNode</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> data; <span class="comment">// 数据域</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">DLNode</span> *<span class="title">prior</span>;</span>    <span class="comment">// 指向前驱结点的指针</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">DLNode</span> *<span class="title">next</span>;</span>    <span class="comment">// 指向后继结点的指针</span></span><br><span class="line">&#125;DLNode;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2- 顺序表的基本操作"><a href="#2- 顺序表的基本操作" class="headerlink" title="2. 顺序表的基本操作"></a>2. 顺序表的基本操作</h2><h3 id="2-1）初始化顺序表"><a href="#2-1）初始化顺序表" class="headerlink" title="2.1）初始化顺序表"></a>2.1）初始化顺序表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initSqlist</span><span class="params">(Sqlist &amp;L)</span> <span class="comment">//L 本身要发生变化，所以用引用型</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	L.length = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2）顺序表的按位查找"><a href="#2-2）顺序表的按位查找" class="headerlink" title="2.2）顺序表的按位查找"></a>2.2）顺序表的按位查找</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSqlist</span><span class="params">(Sqlist L, <span class="keyword">int</span> p, <span class="keyword">int</span> &amp;e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p&lt;<span class="number">0</span> || p&gt;L.length)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	e = L.data[p];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3）顺序表的插入操作"><a href="#2-3）顺序表的插入操作" class="headerlink" title="2.3）顺序表的插入操作"></a>2.3）顺序表的插入操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insertElem</span><span class="params">(Sqlist &amp;L, <span class="keyword">int</span> p, <span class="keyword">int</span> e)</span>   <span class="comment">//L 本身要发生变化，所以要用引用型。此时输入的 p 是需要插入位置的下标，而不是位序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p&lt;<span class="number">0</span> || p&gt;L.length || L.length == maxSize)   <span class="comment">// 如果插入位置错误或者表已满返回 0</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = L.length - <span class="number">1</span>; i &gt;= p; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		L.data[i + <span class="number">1</span>] = L.data[i];</span><br><span class="line">	&#125;</span><br><span class="line">	L.data[p] = e;</span><br><span class="line">	L.length++;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4）顺序表的按值查找"><a href="#2-4）顺序表的按值查找" class="headerlink" title="2.4）顺序表的按值查找"></a>2.4）顺序表的按值查找</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findElem</span><span class="params">(Sqlist L, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (L.data[i] == e)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> i;   <span class="comment">// 此时返回的是元素值为 e 的数组下标 i，其实际位序为 i+1</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-5）顺序表的删除操作"><a href="#2-5）顺序表的删除操作" class="headerlink" title="2.5）顺序表的删除操作"></a>2.5）顺序表的删除操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteElem</span><span class="params">(Sqlist &amp;L, <span class="keyword">int</span> p, <span class="keyword">int</span> &amp;e)</span>   <span class="comment">// 需要改变的变量用引用型</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p&lt;<span class="number">0</span> || p&gt;L.length)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	e = L.data[p];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = p; i &lt;= L.length - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		L.data[i] = L.data[i + <span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	L.length--;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-6）顺序表将 -i-j- 中元素逆置"><a href="#2-6）顺序表将 -i-j- 中元素逆置" class="headerlink" title="2.6）顺序表将 [i:j] 中元素逆置"></a>2.6）顺序表将 [i:j] 中元素逆置</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(Sqlist &amp;L)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, temp;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>, j = L.length - <span class="number">1</span>; i &lt; j; ++i, --j) &#123;</span><br><span class="line">		<span class="comment">// 交换</span></span><br><span class="line">		temp = L.data[i];</span><br><span class="line">		L.data[i] = L.data[j];</span><br><span class="line">		L.data[j] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-7）删除下标为 i-j 的数据元素"><a href="#2-7）删除下标为 i-j 的数据元素" class="headerlink" title="2.7）删除下标为 i~j 的数据元素"></a>2.7）删除下标为 i~j 的数据元素</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteRange</span><span class="params">(Sqlist &amp;L, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    assert(<span class="number">0</span> &lt;= i &amp;&amp; <span class="number">0</span> &lt;= j &amp;&amp; i &lt; L.length &amp;&amp; j &lt; L.length);</span><br><span class="line">    <span class="comment">// 用 j+1 后面的元素去覆盖往前数第 j-i+1 个元素</span></span><br><span class="line">    <span class="keyword">int</span> delta = j - i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = j+<span class="number">1</span>; k &lt; L.length; ++k) &#123;</span><br><span class="line">        L.data[k-delta] = L.data[k];</span><br><span class="line">    &#125;</span><br><span class="line">    L.length -= delta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3- 单链表的基本操作"><a href="#3- 单链表的基本操作" class="headerlink" title="3. 单链表的基本操作"></a>3. 单链表的基本操作</h2><h3 id="3-1）初始化单链表"><a href="#3-1）初始化单链表" class="headerlink" title="3.1）初始化单链表"></a>3.1）初始化单链表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitLinkList</span><span class="params">(LNode *<span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">    assert(<span class="built_in">list</span> != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">list</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2）尾插法建立单链表"><a href="#3-2）尾插法建立单链表" class="headerlink" title="3.2）尾插法建立单链表"></a>3.2）尾插法建立单链表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createLlistR</span><span class="params">(LNode *&amp;<span class="built_in">list</span>, <span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;  <span class="comment">// 要改变的变量用引用型！！</span></span><br><span class="line">	LNode *s, *r;   <span class="comment">//s 指向新创建的结点，r 始终指向新建单链表的尾结点</span></span><br><span class="line">	<span class="built_in">list</span> = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));   <span class="comment">// 先申请 list 头结点空间</span></span><br><span class="line">	<span class="built_in">list</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	r = <span class="built_in">list</span>;   <span class="comment">//r 指向头结点</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));   <span class="comment">//s 指向新建结点</span></span><br><span class="line">		s-&gt;data = a[i];   <span class="comment">// 将数组中的一个数据赋给 s 指向的新结点</span></span><br><span class="line">		r-&gt;next = s;   <span class="comment">// 将新结点插到链表后</span></span><br><span class="line">		r = r-&gt;next;   <span class="comment">//r 指向链表尾结点，用于接收下一个新结点</span></span><br><span class="line">	&#125;</span><br><span class="line">	r-&gt;next = <span class="literal">NULL</span>;  <span class="comment">// 数组中元素全部装入单链表，尾结点指针域置为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3）头插法建立单链表"><a href="#3-3）头插法建立单链表" class="headerlink" title="3.3）头插法建立单链表"></a>3.3）头插法建立单链表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createLlistF</span><span class="params">(LNode *&amp;<span class="built_in">list</span>, <span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;   <span class="comment">// 要改变的变量用引用型！！</span></span><br><span class="line">	LNode *s;</span><br><span class="line">	<span class="built_in">list</span> = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));   <span class="comment">// 申请头指针空间</span></span><br><span class="line">	<span class="built_in">list</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));  <span class="comment">// 申请新的结点</span></span><br><span class="line">		s-&gt;data = a[i];</span><br><span class="line">		s-&gt;next = <span class="built_in">list</span>-&gt;next;   <span class="comment">//s 指向开始结点</span></span><br><span class="line">		<span class="built_in">list</span>-&gt;next = s;   <span class="comment">// 头指针指向 s</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4）归并两升序单链表 A、B 为升序 C（尾插法）"><a href="#3-4）归并两升序单链表 A、B 为升序 C（尾插法）" class="headerlink" title="3.4）归并两升序单链表 A、B 为升序 C（尾插法）"></a>3.4）归并两升序单链表 A、B 为升序 C（尾插法）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeR</span><span class="params">(LNode *A, LNode *B, LNode *&amp;C)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 由于不能改变了 A, B 自己的内容，所以得设定 p, q 来进行操作</span></span><br><span class="line">	LNode *p = A-&gt;next;</span><br><span class="line">	LNode *q = B-&gt;next;</span><br><span class="line">	C = A;   <span class="comment">// 将 A 的头结点作为 C 的头结点</span></span><br><span class="line">	C-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">free</span>(B);   <span class="comment">//B 头结点已无用，释放掉</span></span><br><span class="line">	LNode *r;  <span class="comment">// 尾插法，r 始终指向新链表的尾结点</span></span><br><span class="line">	r = C;</span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; q != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;data &lt;= q-&gt;data) &#123;</span><br><span class="line">			r-&gt;next = p; p = p-&gt;next;   <span class="comment">// 比较后，将数据小的元素尾插入到 r 后，原指针 p 向后移一位</span></span><br><span class="line">			r = r-&gt;next;   <span class="comment">// 插入新结点后，r 向后移，始终指向尾结点</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			r-&gt;next = q; q = q-&gt;next;</span><br><span class="line">			r = r-&gt;next;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	r-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (p != <span class="literal">NULL</span>)   <span class="comment">// 当 B 已扫描完而 A 仍有剩余，则将当前 p 指针所指结点插入到 C 的尾部</span></span><br><span class="line">		r-&gt;next = p;</span><br><span class="line">	<span class="keyword">if</span> (q != <span class="literal">NULL</span>)</span><br><span class="line">		r-&gt;next = q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-5）归并两升序单链表 A、B 为降序 C（头插法）"><a href="#3-5）归并两升序单链表 A、B 为降序 C（头插法）" class="headerlink" title="3.5）归并两升序单链表 A、B 为降序 C（头插法）"></a>3.5）归并两升序单链表 A、B 为降序 C（头插法）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeF</span><span class="params">(LNode *A, LNode *B, LNode *&amp;C)</span> </span>&#123;</span><br><span class="line">    LNode *p = A-&gt;next;</span><br><span class="line">    LNode *q = B-&gt;next;</span><br><span class="line">    LNode *s;</span><br><span class="line">    C = A;</span><br><span class="line">    C-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">free</span>(B);</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; q != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;data &lt;= q-&gt;data) &#123;</span><br><span class="line">            <span class="comment">// 这里就体现出 s 的作用了</span></span><br><span class="line">            <span class="comment">// 如果没有 s，</span></span><br><span class="line">            <span class="comment">// 则直接 p-&gt;next = C-&gt;next, </span></span><br><span class="line">            <span class="comment">// 那么改变了 p 的指向，p 无法再往后挪了</span></span><br><span class="line">            s = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            s-&gt;next = C-&gt;next;</span><br><span class="line">            C-&gt;next = s;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s = q;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">            q-&gt;next = C-&gt;next;</span><br><span class="line">            C-&gt;next = s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于头插，所以这里必须循环将每个剩余元素放到链表 C 的前面去</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        s = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        s-&gt;next = C-&gt;next;</span><br><span class="line">        C-&gt;next = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        s = q;</span><br><span class="line">        q = q-&gt;next;</span><br><span class="line">        s-&gt;next = C-&gt;next;</span><br><span class="line">        C-&gt;next = s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-6）查找元素并删除"><a href="#3-6）查找元素并删除" class="headerlink" title="3.6）查找元素并删除"></a>3.6）查找元素并删除</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findAndDelete</span><span class="params">(LNode *<span class="built_in">list</span>, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先找到该元素</span></span><br><span class="line">    LNode *p;</span><br><span class="line">    p = <span class="built_in">list</span>;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next-&gt;data == x) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 然后删除</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LNode *del;</span><br><span class="line">        del = p-&gt;next;</span><br><span class="line">        p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(del);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="3-7）对于一个递增单链表，删除其重复的元素"><a href="#3-7）对于一个递增单链表，删除其重复的元素" class="headerlink" title="3.7）对于一个递增单链表，删除其重复的元素"></a>3.7）对于一个递增单链表，删除其重复的元素</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteDuplicate</span><span class="params">(LNode *<span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">    LNode *p, *q;  <span class="comment">// q 用来释放被删除的元素</span></span><br><span class="line">    p = <span class="built_in">list</span>-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;data == p-&gt;next-&gt;data) &#123;</span><br><span class="line">            q = p-&gt;next;</span><br><span class="line">            p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(q);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-8）删除单链表中的最小值"><a href="#3-8）删除单链表中的最小值" class="headerlink" title="3.8）删除单链表中的最小值"></a>3.8）删除单链表中的最小值</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteMin</span><span class="params">(LNode *<span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这题的关键是要弄清楚需要哪些指针：</span></span><br><span class="line">    <span class="comment">// p 用来扫描链表，pre 指向 p 的前驱</span></span><br><span class="line">    <span class="comment">// minp 用来指向最小值节点，premin 用来指向 minp 的前驱</span></span><br><span class="line">    LNode *p = <span class="built_in">list</span>-&gt;next, *pre = <span class="built_in">list</span>, *minp = p, *premin = pre;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;data &lt; minp-&gt;data) &#123;</span><br><span class="line">            minp = p;</span><br><span class="line">            premin = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    premin-&gt;next = minp-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(minp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-9）单链表的原地逆置"><a href="#3-9）单链表的原地逆置" class="headerlink" title="3.9）单链表的原地逆置"></a>3.9）单链表的原地逆置</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 L-&gt;NULL 设置为空，然后将剩余的节点一一用头插法插入到 L 中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverseList</span><span class="params">(LNode *<span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">    LNode *p = <span class="built_in">list</span>-&gt;next, *q;</span><br><span class="line">    <span class="built_in">list</span>-&gt;next = <span class="literal">NULL</span>;  <span class="comment">// 断开头节点</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        q = p-&gt;next;  <span class="comment">// 首先得让 q 临时保存一下 p 的下一个节点，待会儿还得用呢</span></span><br><span class="line">        p-&gt;next = <span class="built_in">list</span>-&gt;next;  <span class="comment">// 头插法</span></span><br><span class="line">        <span class="built_in">list</span>-&gt;next = p;</span><br><span class="line">        p = q;  <span class="comment">// 拿回下一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-10）将一个数据域为整数的单链表分割为两个分别为奇数和偶数的链表"><a href="#3-10）将一个数据域为整数的单链表分割为两个分别为奇数和偶数的链表" class="headerlink" title="3.10）将一个数据域为整数的单链表分割为两个分别为奇数和偶数的链表"></a>3.10）将一个数据域为整数的单链表分割为两个分别为奇数和偶数的链表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split2</span><span class="params">(LNode *A, LNode *&amp;B)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// p 用来扫描，但是指向的是要删除节点的前驱</span></span><br><span class="line">    <span class="comment">// q 用来临时保存要删除的节点</span></span><br><span class="line">    <span class="comment">// r 用来指向 B 中的终端节点</span></span><br><span class="line">    LNode *p, *q, *r;</span><br><span class="line">    B = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    B-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 每申请一个新的节点，都将指针域设置为空，这样可以避免出事儿</span></span><br><span class="line">    p = A;</span><br><span class="line">    r = B;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;next-&gt;data%<span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            q = p-&gt;next;</span><br><span class="line">            p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">            r-&gt;next = q;</span><br><span class="line">            r = q;</span><br><span class="line">            q-&gt;next = <span class="literal">NULL</span>;  <span class="comment">// 不写这句话绝对出事</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-11）逆序打印单链表中的节点"><a href="#3-11）逆序打印单链表中的节点" class="headerlink" title="3.11）逆序打印单链表中的节点"></a>3.11）逆序打印单链表中的节点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逆序，入栈不就逆序了吗，所以可以考虑递归打印</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reprintList</span><span class="params">(LNode *<span class="built_in">list</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span> != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        reprintList(<span class="built_in">list</span>-&gt;next);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">list</span>-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-12）查找链表中倒数第 k 个节点"><a href="#3-12）查找链表中倒数第 k 个节点" class="headerlink" title="3.12）查找链表中倒数第 k 个节点"></a>3.12）查找链表中倒数第 k 个节点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findkLast</span><span class="params">(LNode *<span class="built_in">list</span>, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    LNode *p, *q;</span><br><span class="line">    p = <span class="built_in">list</span>-&gt;next;</span><br><span class="line">    q = <span class="built_in">list</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        ++i;  <span class="comment">// 这里的计数器 i 自己画图给弄清楚</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; k) q = q-&gt;next; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q == <span class="built_in">list</span>) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 链表的节点不到 k 个</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-13）将两个升序单链表 A、B 求差集 A-B 存入 A 中"><a href="#3-13）将两个升序单链表 A、B 求差集 A-B 存入 A 中" class="headerlink" title="3.13）将两个升序单链表 A、B 求差集 A-B 存入 A 中"></a>3.13）将两个升序单链表 A、B 求差集 A-B 存入 A 中</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">difference</span><span class="params">(LNode *A,LNode *B)</span></span>&#123;</span><br><span class="line">	LNode *a,*b,*c;</span><br><span class="line">	</span><br><span class="line">	a=A;<span class="comment">//a 指向 A 链表头结点</span></span><br><span class="line">	b=B;<span class="comment">//b 指向 B 链表头结点</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(a-&gt;next!=<span class="literal">NULL</span>&amp;&amp;b-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a-&gt;next-&gt;data &lt; b-&gt;next-&gt;data)</span><br><span class="line">			a = a-&gt;next;<span class="comment">// 如果 a 所指的值小于 b 所指的值，则 a 后移一位</span></span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(a-&gt;next-&gt;data &gt; b-&gt;next-&gt;data)</span><br><span class="line">			b = b-&gt;next;<span class="comment">// 如果 b 所指的值小于 a 所指的值，则 b 后移一位</span></span><br><span class="line">		<span class="keyword">else</span>&#123;<span class="comment">// 如果两者所指指针的值相同，则删除 a 所指结点</span></span><br><span class="line">			c = a-&gt;next;</span><br><span class="line">			a-&gt;next = a-&gt;next-&gt;next;</span><br><span class="line">			<span class="built_in">free</span>(c);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4- 双链表的基本操作"><a href="#4- 双链表的基本操作" class="headerlink" title="4. 双链表的基本操作"></a>4. 双链表的基本操作</h2><h3 id="4-1）尾插法建立双链表"><a href="#4-1）尾插法建立双链表" class="headerlink" title="4.1）尾插法建立双链表"></a>4.1）尾插法建立双链表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createDlistR</span><span class="params">(DLNode *&amp;L, <span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	DLNode *s, *r;</span><br><span class="line">	L = (DLNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DLNode));</span><br><span class="line">	L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	L-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">	r = L;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		s = (DLNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DLNode));</span><br><span class="line">		<span class="comment">// 下面三句为尾插法关键代码，与单链表不同的是，要使新结点 s-&gt;prior=r</span></span><br><span class="line">		s-&gt;data = a[i];</span><br><span class="line">		r-&gt;next = s;</span><br><span class="line">		s-&gt;prior = r;</span><br><span class="line">		r = s;</span><br><span class="line">	&#125;</span><br><span class="line">	r-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2）双链表查找结点"><a href="#4-2）双链表查找结点" class="headerlink" title="4.2）双链表查找结点"></a>4.2）双链表查找结点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DLNode* <span class="title">findNode</span><span class="params">(DLNode *<span class="built_in">list</span>, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    DLNode *p = <span class="built_in">list</span>-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;data == x) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3）双链表插入结点"><a href="#4-3）双链表插入结点" class="headerlink" title="4.3）双链表插入结点"></a>4.3）双链表插入结点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">insertDlist</span><span class="params">(DLNode *&amp;<span class="built_in">list</span>, <span class="keyword">int</span> index, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (index &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	DLNode *p = <span class="built_in">list</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	DLNode *s = (DLNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DLNode));</span><br><span class="line">	s-&gt;data = e;</span><br><span class="line">	<span class="comment">// 插入关键代码</span></span><br><span class="line">	s-&gt;next = p-&gt;next;</span><br><span class="line">	s-&gt;prior = p;</span><br><span class="line">	p-&gt;next = s;</span><br><span class="line">	s-&gt;next-&gt;prior = s;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4）双链表插入删除"><a href="#4-4）双链表插入删除" class="headerlink" title="4.4）双链表插入删除"></a>4.4）双链表插入删除</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteDlist</span><span class="params">(DLNode *&amp;<span class="built_in">list</span>, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">	DLNode *p = <span class="built_in">list</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删除关键代码</span></span><br><span class="line">	DLNode *s = p-&gt;next;</span><br><span class="line">	p-&gt;next = s-&gt;next;</span><br><span class="line">	<span class="keyword">if</span> (s-&gt;next != <span class="literal">NULL</span>) &#123;  <span class="comment">// 不加这个判断也是会出事的</span></span><br><span class="line">		s-&gt;next-&gt;prior = p;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(s);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5- 栈和队列的结构体定义"><a href="#5- 栈和队列的结构体定义" class="headerlink" title="5. 栈和队列的结构体定义"></a>5. 栈和队列的结构体定义</h2><h3 id="5-1）顺序栈的定义"><a href="#5-1）顺序栈的定义" class="headerlink" title="5.1）顺序栈的定义"></a>5.1）顺序栈的定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> data[maxSize];</span><br><span class="line">	<span class="keyword">int</span> top;   <span class="comment">// 栈顶指针</span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure>

<h3 id="5-2）链栈结点定义"><a href="#5-2）链栈结点定义" class="headerlink" title="5.2）链栈结点定义"></a>5.2）链栈结点定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> data;   <span class="comment">// 数据域</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span>   <span class="comment">// 指针域</span></span><br><span class="line">&#125;LNode;</span><br></pre></td></tr></table></figure>

<h3 id="5-3）顺序队列的定义"><a href="#5-3）顺序队列的定义" class="headerlink" title="5.3）顺序队列的定义"></a>5.3）顺序队列的定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> data[maxSize];</span><br><span class="line">	<span class="keyword">int</span> front;   <span class="comment">// 队头指针</span></span><br><span class="line">	<span class="keyword">int</span> rear;   <span class="comment">// 队尾指针</span></span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure>

<h3 id="5-4）链队定义"><a href="#5-4）链队定义" class="headerlink" title="5.4）链队定义"></a>5.4）链队定义</h3><h4 id="（5-4-1）队结点类型定义"><a href="#（5-4-1）队结点类型定义" class="headerlink" title="（5.4.1）队结点类型定义"></a>（5.4.1）队结点类型定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;  <span class="comment">// 数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span>   <span class="comment">// 指针域</span></span><br><span class="line">&#125;QNode;</span><br></pre></td></tr></table></figure>

<h4 id="（5-4-2）链队类型定义"><a href="#（5-4-2）链队类型定义" class="headerlink" title="（5.4.2）链队类型定义"></a>（5.4.2）链队类型定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    QNode *front;  <span class="comment">// 队头指针</span></span><br><span class="line">    QNode *rear;  <span class="comment">// 队尾指针</span></span><br><span class="line">&#125;LiQueue;</span><br></pre></td></tr></table></figure>

<h2 id="6- 顺序栈的基本操作"><a href="#6- 顺序栈的基本操作" class="headerlink" title="6. 顺序栈的基本操作"></a>6. 顺序栈的基本操作</h2><h3 id="6-1）顺序栈的初始化"><a href="#6-1）顺序栈的初始化" class="headerlink" title="6.1）顺序栈的初始化"></a>6.1）顺序栈的初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initStack</span><span class="params">(SqStack &amp;st)</span> </span>&#123;</span><br><span class="line">    st.top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-2）判断栈空栈满"><a href="#6-2）判断栈空栈满" class="headerlink" title="6.2）判断栈空栈满"></a>6.2）判断栈空栈满</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isEmpty</span><span class="params">(SqStack st)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> st.top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isFull</span><span class="params">(SqStack st)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> st.top == maxSize - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-3）进栈代码"><a href="#6-3）进栈代码" class="headerlink" title="6.3）进栈代码"></a>6.3）进栈代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">push</span><span class="params">(SqStack &amp;st, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (st.top == maxSize - <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	++st.top;   <span class="comment">// 先移动指针，再进栈</span></span><br><span class="line">	st.data[st.top] = x;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-4）出栈代码"><a href="#6-4）出栈代码" class="headerlink" title="6.4）出栈代码"></a>6.4）出栈代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(SqStack &amp;st, <span class="keyword">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (st.top == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	x = st.data[st.top];  <span class="comment">// 先取出元素，再出栈</span></span><br><span class="line">	st.top--;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-5）考试中顺序栈用法的简洁写法"><a href="#6-5）考试中顺序栈用法的简洁写法" class="headerlink" title="6.5）考试中顺序栈用法的简洁写法"></a>6.5）考试中顺序栈用法的简洁写法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">stack</span>[maxSize]; <span class="keyword">int</span> top = <span class="number">-1</span>;  <span class="comment">// 这两句话连定义带初始化都有了</span></span><br><span class="line"><span class="built_in">stack</span>[++top] = x;  <span class="comment">// 一句话实现进栈</span></span><br><span class="line">x = <span class="built_in">stack</span>[top--];  <span class="comment">// 一句话实现出栈</span></span><br></pre></td></tr></table></figure>

<h2 id="7- 链栈的基本操作"><a href="#7- 链栈的基本操作" class="headerlink" title="7. 链栈的基本操作"></a>7. 链栈的基本操作</h2><h3 id="7-1）链栈的初始化"><a href="#7-1）链栈的初始化" class="headerlink" title="7.1）链栈的初始化"></a>7.1）链栈的初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initStack</span><span class="params">(LNode *&amp;lst)</span> </span>&#123;</span><br><span class="line">    lst = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    lst-&gt;next = <span class="literal">NULL</span>;  <span class="comment">// 申请新的节点后一定要为其指针域设置为空</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-2）判断栈空"><a href="#7-2）判断栈空" class="headerlink" title="7.2）判断栈空"></a>7.2）判断栈空</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isEmpty</span><span class="params">(LNode *lst)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (lst-&gt;next = <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-3）进栈代码"><a href="#7-3）进栈代码" class="headerlink" title="7.3）进栈代码"></a>7.3）进栈代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(LNode *&amp;lst, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	LNode *p;</span><br><span class="line">	p = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));   <span class="comment">// 制造一个结点</span></span><br><span class="line">	p-&gt;next = <span class="literal">NULL</span>;   <span class="comment">// 这是一个好习惯</span></span><br><span class="line">	<span class="comment">// 头插法</span></span><br><span class="line">	p-&gt;data = x;</span><br><span class="line">	p-&gt;next = lst-&gt;next;</span><br><span class="line">	lst-&gt;next = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-4）出栈代码"><a href="#7-4）出栈代码" class="headerlink" title="7.4）出栈代码"></a>7.4）出栈代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(LNode *&amp;lst, <span class="keyword">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (lst-&gt;next = <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	LNode *p;</span><br><span class="line">	p = lst-&gt;next;</span><br><span class="line">	x = p-&gt;data;</span><br><span class="line">	lst-&gt;next = p-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8- 顺序队列的基本操作"><a href="#8- 顺序队列的基本操作" class="headerlink" title="8. 顺序队列的基本操作"></a>8. 顺序队列的基本操作</h2><h3 id="8-1）顺序队列的初始化"><a href="#8-1）顺序队列的初始化" class="headerlink" title="8.1）顺序队列的初始化"></a>8.1）顺序队列的初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initQueue</span><span class="params">(SqQueue &amp;qu)</span> </span>&#123;</span><br><span class="line">    qu.front = qu.rear = <span class="number">0</span>;  <span class="comment">// 队首和队尾指针重合，并且指向 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-2）判断队空队满"><a href="#8-2）判断队空队满" class="headerlink" title="8.2）判断队空队满"></a>8.2）判断队空队满</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isQueueEmpty</span><span class="params">(SqQueue qu)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> qu.front == qu.rear;  <span class="comment">// 只要重合，即为空队</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isQueueFull</span><span class="params">(SqQueue qu)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> qu.front == (qu.rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-3）进队算法"><a href="#8-3）进队算法" class="headerlink" title="8.3）进队算法"></a>8.3）进队算法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">enQueue</span><span class="params">(SqQueue &amp;qu, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((qu.rear+<span class="number">1</span>)%maxSize == qu.front) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 队满则不能入队</span></span><br><span class="line">    qu.rear = (qu.rear+<span class="number">1</span>)%maxSize;  <span class="comment">// 若未满，则先移动指针</span></span><br><span class="line">    qu.data[qu.rear] = x;  <span class="comment">// 再放入元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-4）出队算法"><a href="#8-4）出队算法" class="headerlink" title="8.4）出队算法"></a>8.4）出队算法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deQueue</span><span class="params">(SqQueue &amp;qu, <span class="keyword">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (qu.front == qu.rear)  <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 若队空，则不能删除</span></span><br><span class="line">    qu.front = (qu.front+<span class="number">1</span>)%maxSize;  <span class="comment">// 若队不空，则先移动指针</span></span><br><span class="line">    x = qu.data[qu.front];  <span class="comment">// 再取出元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9- 链队的基本操作"><a href="#9- 链队的基本操作" class="headerlink" title="9. 链队的基本操作"></a>9. 链队的基本操作</h2><h3 id="9-1）链队的初始化"><a href="#9-1）链队的初始化" class="headerlink" title="9.1）链队的初始化"></a>9.1）链队的初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initQueue</span><span class="params">(LiQueue *&amp;lqu)</span> </span>&#123;</span><br><span class="line">	lqu = (LiQueue *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LiQueue));</span><br><span class="line">	lqu-&gt;front = lqu-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-2）判断队空算法"><a href="#9-2）判断队空算法" class="headerlink" title="9.2）判断队空算法"></a>9.2）判断队空算法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isEmptyQueue</span><span class="params">(LiQueue *lqu)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (lqu-&gt;front == <span class="literal">NULL</span> || lqu-&gt;rear == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-3）入队算法"><a href="#9-3）入队算法" class="headerlink" title="9.3）入队算法"></a>9.3）入队算法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enQueue</span><span class="params">(LiQueue *&amp;lqu, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	QNode *p;</span><br><span class="line">	p = (QNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">	p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	p-&gt;data = x;</span><br><span class="line">	<span class="keyword">if</span> (lqu-&gt;rear == <span class="literal">NULL</span>)   <span class="comment">// 如果队列为空，那新结点既是队首结点也是队尾结点</span></span><br><span class="line">		lqu-&gt;front = lqu-&gt;rear = p;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		lqu-&gt;rear-&gt;next = p;</span><br><span class="line">		lqu-&gt;rear = p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-4）出队算法"><a href="#9-4）出队算法" class="headerlink" title="9.4）出队算法"></a>9.4）出队算法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deQueue</span><span class="params">(LiQueue *&amp;lqu, <span class="keyword">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line">	QNode *p;</span><br><span class="line">	<span class="keyword">if</span> (lqu-&gt;front == <span class="literal">NULL</span> || lqu-&gt;rear == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		p = lqu-&gt;front;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (lqu-&gt;front == lqu-&gt;rear)   <span class="comment">// 队列中只有一个结点时出队操作要特殊处理</span></span><br><span class="line">	&#123;</span><br><span class="line">		lqu-&gt;front = lqu-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		lqu-&gt;front = lqu-&gt;front-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	x = p-&gt;data;</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10- 栈的应用"><a href="#10- 栈的应用" class="headerlink" title="10. 栈的应用"></a>10. 栈的应用</h2><h3 id="10-1）括号匹配问题"><a href="#10-1）括号匹配问题" class="headerlink" title="10.1）括号匹配问题"></a>10.1）括号匹配问题</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span> A[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> <span class="built_in">stack</span>[maxSize];<span class="comment">// 两句话完成栈的定义和初始化</span></span><br><span class="line">	<span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(A[i] == <span class="string">&#x27;(&#x27;</span>)&#123;<span class="comment">// 如果遇到左括号，则入栈等待处理</span></span><br><span class="line">			<span class="built_in">stack</span>[++top] = <span class="string">&#x27;(&#x27;</span>;<span class="comment">// 一句话完成入栈操作</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(A[i] == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">			<span class="keyword">if</span>(top == <span class="number">-1</span>)<span class="comment">// 如果碰到了右括号并且栈已空，则不匹配，返回 0</span></span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				--top;<span class="comment">// 若碰到右括号栈不空，则出栈，相当于完成一对括号匹配</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(top==<span class="number">-1</span>) <span class="comment">// 遍历完成后，栈空，证明所有括号都配对</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span><span class="comment">// 否则括号不匹配</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-2）计算后缀表达式"><a href="#10-2）计算后缀表达式" class="headerlink" title="10.2）计算后缀表达式"></a>10.2）计算后缀表达式</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">op</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">char</span> op,<span class="keyword">int</span> b)</span></span>&#123;<span class="comment">// 本函数是运算函数，用来完成算式“a op b”的运算</span></span><br><span class="line">	<span class="keyword">if</span>(op==<span class="string">&#x27;+&#x27;</span>) <span class="keyword">return</span> a+b;</span><br><span class="line">	<span class="keyword">if</span>(op==<span class="string">&#x27;-&#x27;</span>) <span class="keyword">return</span> a-b;</span><br><span class="line">	<span class="keyword">if</span>(op==<span class="string">&#x27;*&#x27;</span>) <span class="keyword">return</span> a*b;</span><br><span class="line">	<span class="keyword">if</span>(op==<span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b==<span class="number">0</span>)&#123;<span class="comment">// 判断，0 不能作除数</span></span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;b 不可以为 0&quot;</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> a/b;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">com</span><span class="params">(<span class="keyword">char</span> <span class="built_in">exp</span>[])</span></span>&#123;<span class="comment">// 后缀表达式计算函数</span></span><br><span class="line">	<span class="keyword">int</span> <span class="built_in">stack</span>[maxSize],top=<span class="number">-1</span>,a,b,c;<span class="comment">// 栈的定义和初始化，a，b 为操作数，c 来保存结果</span></span><br><span class="line">	<span class="keyword">char</span> opa;<span class="comment">//opa 用来取运算符</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;<span class="built_in">exp</span>[i]!=<span class="string">&#x27;\0&#x27;</span>;++i)&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">exp</span>[i]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;<span class="built_in">exp</span>[i]&lt;=<span class="string">&#x27;9&#x27;</span>)<span class="comment">// 如果遇到操作数则入栈等待处理</span></span><br><span class="line">			<span class="built_in">stack</span>[++top] = <span class="built_in">exp</span>[i] - <span class="string">&#x27;0&#x27;</span>;<span class="comment">// 注意字符型与整型的转换</span></span><br><span class="line">		<span class="keyword">else</span>&#123;<span class="comment">// 如果遇到运算符，则说明前面待处理的数字已具备处理条件，开始运算</span></span><br><span class="line">			opa = <span class="built_in">exp</span>[i];<span class="comment">// 取运算符</span></span><br><span class="line">			b = <span class="built_in">stack</span>[top--];<span class="comment">// 从栈中取出第二个操作数（因为栈先进后出特性，所以先出栈的是第二个操作数）</span></span><br><span class="line">			a = <span class="built_in">stack</span>[top--];<span class="comment">// 从栈中取出第一个操作数</span></span><br><span class="line">			</span><br><span class="line">			c = op(a,opa,b);<span class="comment">// 两个操作数结合运算符 opa 进行运算，结果保存在 c 中</span></span><br><span class="line">			<span class="built_in">stack</span>[++top] = c; <span class="comment">// 运算结构入栈</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">stack</span>[<span class="number">0</span>];</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11- 数组"><a href="#11- 数组" class="headerlink" title="11. 数组"></a>11. 数组</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归求数组内最大值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getmax</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i==n_1<span class="number">-1</span>) <span class="keyword">return</span> A[n_1<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">return</span> (getmax(A,i+<span class="number">1</span>)&gt;A[i])?getmax(A,i+<span class="number">1</span>):A[i];	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归求数组和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i==n_1<span class="number">-1</span>) <span class="keyword">return</span> A[n_1<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">return</span> getsum(A,i+<span class="number">1</span>)+A[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归求数组平均</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">getavg</span><span class="params">(<span class="keyword">float</span> A[],<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i==n_1<span class="number">-1</span>) <span class="keyword">return</span> A[n_1<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">return</span> (getavg(A,i+<span class="number">1</span>)*(n_1-i<span class="number">-1</span>)+A[i])/(n_1-i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把数组内所有奇数放在偶数前</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>,j=n<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">		<span class="keyword">while</span>(i&lt;j&amp;&amp;A[i]%<span class="number">2</span>==<span class="number">1</span>) ++i;</span><br><span class="line">		<span class="keyword">while</span>(i&lt;j&amp;&amp;A[j]%<span class="number">2</span>==<span class="number">0</span>) --j;</span><br><span class="line">		<span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">			<span class="keyword">int</span> t=A[i];</span><br><span class="line">			A[i]=A[j];</span><br><span class="line">			A[j]=t;</span><br><span class="line">			++i;</span><br><span class="line">			--j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="12- 二叉树的结点定义"><a href="#12- 二叉树的结点定义" class="headerlink" title="12. 二叉树的结点定义"></a>12. 二叉树的结点定义</h2><h3 id="12-1）普通二叉树的链式存储结点定义"><a href="#12-1）普通二叉树的链式存储结点定义" class="headerlink" title="12.1）普通二叉树的链式存储结点定义"></a>12.1）普通二叉树的链式存储结点定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;   <span class="comment">// 这里默认结点 data 域为 char 类型</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> *<span class="title">lchild</span>;</span>  <span class="comment">// 左儿子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> *<span class="title">rchild</span>;</span>  <span class="comment">// 右儿子</span></span><br><span class="line">&#125;BTNode;</span><br></pre></td></tr></table></figure>

<h3 id="12-2）线索二叉树的结点定义"><a href="#12-2）线索二叉树的结点定义" class="headerlink" title="12.2）线索二叉树的结点定义"></a>12.2）线索二叉树的结点定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线索二叉树</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TBTNode</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span> data;</span><br><span class="line">	<span class="keyword">int</span> ltag, rtag;<span class="comment">// 线索标记</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">TBTNode</span> *<span class="title">lchild</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">TBTNode</span> *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;TBTNode;</span><br></pre></td></tr></table></figure>

<h2 id="13- 二叉树的操作"><a href="#13- 二叉树的操作" class="headerlink" title="13. 二叉树的操作"></a>13. 二叉树的操作</h2><h3 id="13-1）先序遍历（递归）"><a href="#13-1）先序遍历（递归）" class="headerlink" title="13.1）先序遍历（递归）"></a>13.1）先序遍历（递归）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorder</span><span class="params">(BTNode *p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		visit(p);</span><br><span class="line">		preorder(p-&gt;lchild);</span><br><span class="line">		preorder(p-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-2）中序遍历（递归）"><a href="#13-2）中序遍历（递归）" class="headerlink" title="13.2）中序遍历（递归）"></a>13.2）中序遍历（递归）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(BTNode *p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		inorder(p-&gt;lchild);</span><br><span class="line">		visit(p);</span><br><span class="line">		inorder(p-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-3）后序遍历（递归）"><a href="#13-3）后序遍历（递归）" class="headerlink" title="13.3）后序遍历（递归）"></a>13.3）后序遍历（递归）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorder</span><span class="params">(BTNode *p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		postorder(p-&gt;lchild);</span><br><span class="line">		postorder(p-&gt;rchild);</span><br><span class="line">		visit(p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-4）层序遍历"><a href="#13-4）层序遍历" class="headerlink" title="13.4）层序遍历"></a>13.4）层序遍历</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">level</span><span class="params">(BTNode *p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> front, rear;</span><br><span class="line">	BTNode *que[maxSize];<span class="comment">// 定义循环队列</span></span><br><span class="line">	front = rear = <span class="number">0</span>;</span><br><span class="line">	BTNode *q;</span><br><span class="line">	<span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		rear = (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">		que[rear] = p;<span class="comment">// 根结点入队</span></span><br><span class="line">		<span class="keyword">while</span> (front != rear)<span class="comment">// 当队列不为空时进行循环</span></span><br><span class="line">		&#123;</span><br><span class="line">			front = (front + <span class="number">1</span>) % maxSize;</span><br><span class="line">			q = que[front];<span class="comment">// 队头结点出队</span></span><br><span class="line">			visit(q);<span class="comment">// 访问队头结点</span></span><br><span class="line">			<span class="keyword">if</span> (q-&gt;lchild != <span class="literal">NULL</span>)<span class="comment">// 若左子树不为空，则左子树的根结点入队</span></span><br><span class="line">			&#123;</span><br><span class="line">				rear = (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">				que[rear] = q-&gt;lchild;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (q-&gt;rchild != <span class="literal">NULL</span>)<span class="comment">// 若右子树不为空，则右子树的根结点入队</span></span><br><span class="line">			&#123;</span><br><span class="line">				rear = (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">				que[rear] = q-&gt;rchild;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-5）先序遍历（非递归）"><a href="#13-5）先序遍历（非递归）" class="headerlink" title="13.5）先序遍历（非递归）"></a>13.5）先序遍历（非递归）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preorderNonrecursion</span><span class="params">(BTNode *bt)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (bt != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		BTNode *Stack[maxSize];<span class="comment">// 定义一个栈</span></span><br><span class="line">		<span class="keyword">int</span> top = <span class="number">-1</span>;<span class="comment">// 初始化栈</span></span><br><span class="line">		BTNode *p;</span><br><span class="line">		Stack[++top] = bt;<span class="comment">// 根结点入栈</span></span><br><span class="line">		<span class="keyword">while</span> (top != <span class="number">-1</span>)<span class="comment">// 栈空则退出循环，遍历结束</span></span><br><span class="line">		&#123;</span><br><span class="line">			p = Stack[top--];<span class="comment">// 出栈并输出栈顶结点</span></span><br><span class="line">			visit(p);<span class="comment">// 访问出栈结点</span></span><br><span class="line">			<span class="keyword">if</span> (p-&gt;rchild != <span class="literal">NULL</span>)<span class="comment">// 若栈顶结点右孩子存在，则右孩子入栈</span></span><br><span class="line">			&#123;</span><br><span class="line">				Stack[++top] = p-&gt;rchild;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (p-&gt;lchild != <span class="literal">NULL</span>)<span class="comment">// 若栈顶结点左孩子存在，则左孩子入栈</span></span><br><span class="line">			&#123;</span><br><span class="line">				Stack[++top] = p-&gt;lchild;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-6）中序遍历（非递归）"><a href="#13-6）中序遍历（非递归）" class="headerlink" title="13.6）中序遍历（非递归）"></a>13.6）中序遍历（非递归）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inorderNonrecursion</span><span class="params">(BTNode *bt)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (bt != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		BTNode *Stack[maxSize];</span><br><span class="line">		<span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">		BTNode *p;</span><br><span class="line">		p = bt;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (top != <span class="number">-1</span> || p != <span class="literal">NULL</span>)<span class="comment">// 栈非空或 p 非空时循环继续！！！</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span> (p != <span class="literal">NULL</span>) <span class="comment">// 左孩子存在则左孩子一直入栈</span></span><br><span class="line">			&#123;</span><br><span class="line">				Stack[++top] = p;</span><br><span class="line">				p = p-&gt;lchild;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (top != <span class="number">-1</span>)<span class="comment">// 在栈不空的情况下出栈并输出出栈结点</span></span><br><span class="line">			&#123;</span><br><span class="line">				p = Stack[top--];</span><br><span class="line">				visit(p);</span><br><span class="line">				p = p-&gt;rchild;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-7）后序遍历（非递归）"><a href="#13-7）后序遍历（非递归）" class="headerlink" title="13.7）后序遍历（非递归）"></a>13.7）后序遍历（非递归）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postorderNonrecursion</span><span class="params">(BTNode *bt)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (bt != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 定义两个栈</span></span><br><span class="line">		BTNode *Stack1[maxSize]; <span class="keyword">int</span> top1 = <span class="number">-1</span>;</span><br><span class="line">		BTNode *Stack2[maxSize]; <span class="keyword">int</span> top2 = <span class="number">-1</span>;</span><br><span class="line">		BTNode *p = <span class="literal">NULL</span>;</span><br><span class="line">		Stack1[++top1] = bt;<span class="comment">// 根结点入栈</span></span><br><span class="line">		<span class="keyword">while</span> (top1 != <span class="number">-1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			p = Stack1[top1--];</span><br><span class="line">			Stack2[++top2] = p;<span class="comment">// 出 1 栈后马上入 2 栈</span></span><br><span class="line">			<span class="keyword">if</span> (p-&gt;lchild != <span class="literal">NULL</span>)<span class="comment">// 若栈顶结点左孩子存在，则左孩子入栈</span></span><br><span class="line">			&#123;</span><br><span class="line">				Stack1[++top1] = p-&gt;lchild;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (p-&gt;rchild != <span class="literal">NULL</span>)<span class="comment">// 若栈顶结点右孩子存在，则右孩子入栈</span></span><br><span class="line">			&#123;</span><br><span class="line">				Stack1[++top1] = p-&gt;rchild;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (top2 != <span class="literal">NULL</span>)<span class="comment">// 出栈序列即为后序遍历序列</span></span><br><span class="line">		&#123;</span><br><span class="line">			p = Stack2[top2--];</span><br><span class="line">			visit(p);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-8）二叉树中序线索化"><a href="#13-8）二叉树中序线索化" class="headerlink" title="13.8）二叉树中序线索化"></a>13.8）二叉树中序线索化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThread</span><span class="params">(TBTNode *p, TBTNode *&amp;pre)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		InThread(p-&gt;lchild, pre);<span class="comment">// 递归，左子树线索化</span></span><br><span class="line">		<span class="keyword">if</span> (p-&gt;lchild != <span class="literal">NULL</span>)<span class="comment">// 建立当前结点的前驱结点</span></span><br><span class="line">		&#123;</span><br><span class="line">			p-&gt;lchild = pre;</span><br><span class="line">			p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;rchild != <span class="literal">NULL</span>)<span class="comment">// 建立前驱结点的后继结点</span></span><br><span class="line">		&#123;</span><br><span class="line">			pre-&gt;rchild = p;</span><br><span class="line">			pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		pre = p;<span class="comment">//pre 指向当前结点 p，作为 p 将要指向下一个结点的前驱结点指示指针</span></span><br><span class="line">		InThread(p-&gt;rchild, pre);<span class="comment">// 递归，右子树线索化</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-9）通过中序遍历建立中序线索二叉树"><a href="#13-9）通过中序遍历建立中序线索二叉树" class="headerlink" title="13.9）通过中序遍历建立中序线索二叉树"></a>13.9）通过中序遍历建立中序线索二叉树</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createInThread</span><span class="params">(TBTNode *root)</span> </span>&#123;</span><br><span class="line">	TBTNode *pre = <span class="literal">NULL</span>;<span class="comment">// 前驱结点指针</span></span><br><span class="line">	<span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		InThread(root, pre);</span><br><span class="line">		pre-&gt;rchild = <span class="literal">NULL</span>;<span class="comment">// 非空二叉树，线索化后处理中序最后一个结点</span></span><br><span class="line">		pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-10）中序线索二叉树的遍历"><a href="#13-10）中序线索二叉树的遍历" class="headerlink" title="13.10）中序线索二叉树的遍历"></a>13.10）中序线索二叉树的遍历</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求以 p 为根的中序线索二叉树中，中序序列的第一个结点</span></span><br><span class="line"><span class="function">TBTNode *<span class="title">First</span><span class="params">(TBTNode *p)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (p-&gt;ltag == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		p = p-&gt;lchild;<span class="comment">// 最左下结点就是中序序列第一个结点（不一定为叶子节点）</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 求中序线索二叉树中，结点 p 在中序下的后继结点</span></span><br><span class="line"><span class="function">TBTNode *<span class="title">Next</span><span class="params">(TBTNode *p)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/* 如果 p 右指针不是线索，先往右走一步，再一直往左走，最左下结点就是它的后继；</span></span><br><span class="line"><span class="comment">	  如果 p 右指针是线索，那右指针所指就是它后继 */</span></span><br><span class="line">	<span class="keyword">if</span> (p-&gt;rtag == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> First(p-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> p-&gt;rchild;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由中序线索二叉树的 First 和 Next 函数，很容易遍历中序序列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inorder</span><span class="params">(TBTNode *root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (TBTNode *p = First(root); p != <span class="literal">NULL</span>; p = Next(p))</span><br><span class="line">	&#123;</span><br><span class="line">		visit(p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-11）求二叉树深度"><a href="#13-11）求二叉树深度" class="headerlink" title="13.11）求二叉树深度"></a>13.11）求二叉树深度</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(BTNode *T)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> L,R;</span><br><span class="line">	<span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// 如果树是空树，返回 0</span></span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		L = getDepth(T-&gt;lchild);<span class="comment">// 求左子树深度</span></span><br><span class="line">		R = getDepth(T-&gt;rchild);<span class="comment">// 求右子树深度</span></span><br><span class="line">		<span class="keyword">return</span> (L&gt;R?L:R)+<span class="number">1</span>;<span class="comment">// 返回左右子树深度的最大值加 1</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-12）求二叉树宽度（考过）"><a href="#13-12）求二叉树宽度（考过）" class="headerlink" title="13.12）求二叉树宽度（考过）"></a><em>13.12）求二叉树宽度（考过）</em></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">levelOrder</span><span class="params">(BTNode *T)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> rear=<span class="number">0</span>,front=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> L=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> n,max;</span><br><span class="line">	St qu[maxSize];</span><br><span class="line">	BTNode *r;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		</span><br><span class="line">		++rear;</span><br><span class="line">		qu[rear].p = T;</span><br><span class="line">		qu[rear].l = <span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(rear!=front)&#123;</span><br><span class="line">			++front;</span><br><span class="line">			r = qu[front].p;</span><br><span class="line">			L = qu[front].l;</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(r-&gt;lchild!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">				++rear;</span><br><span class="line">				qu[rear].p = r-&gt;lchild;</span><br><span class="line">				qu[rear].l = L+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(r-&gt;rchild!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">				++rear;</span><br><span class="line">				qu[rear].p = r-&gt;rchild;</span><br><span class="line">				qu[rear].l = L+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		max = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=L;i++)&#123;</span><br><span class="line">			n = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=rear;++j)&#123;</span><br><span class="line">				<span class="keyword">if</span>(qu[j].l==i) ++n;</span><br><span class="line">				<span class="keyword">if</span>(max&lt;n) max=n;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;max&lt;&lt;<span class="string">&quot;**&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> max;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-13）查找指定值 key"><a href="#13-13）查找指定值 key" class="headerlink" title="13.13）查找指定值 key"></a>13.13）查找指定值 key</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(BTNode *T,BTNode *&amp;q,<span class="keyword">char</span> key)</span></span>&#123;<span class="comment">// 参数 q 定义为引用型指针，因为 q 要改变</span></span><br><span class="line">	<span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(T-&gt;data==key) q=T;<span class="comment">// 如果 T 所指结点的 data 值等于 key，则将 q 指向该结点</span></span><br><span class="line">		<span class="keyword">else</span>&#123;<span class="comment">// 如果 T 所指结点的 data 值不等于 key，则分别到左右子树中查找</span></span><br><span class="line">			find(T-&gt;lchild,q,key);<span class="comment">// 到左子树查找</span></span><br><span class="line">			find(T-&gt;rchild,q,key);<span class="comment">// 到右子树查找</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-14）查找前中后序中第 k 个值"><a href="#13-14）查找前中后序中第 k 个值" class="headerlink" title="13.14）查找前中后序中第 k 个值"></a>13.14）查找前中后序中第 k 个值</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n=<span class="number">0</span>;<span class="comment">// 定义全局变量 n，将结点计数初值设为 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(BTNode *T,<span class="keyword">int</span> key)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		++n;<span class="comment">// 当第一次来到一个结点的时候计数，表示这是第 n 个结点</span></span><br><span class="line">		<span class="keyword">if</span>(n==key)&#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;T-&gt;data;<span class="comment">// 判断是不是先序序列第 k 个结点；如果是则输出</span></span><br><span class="line">			<span class="keyword">return</span>;<span class="comment">// 并且无需继续遍历，用 return 返回</span></span><br><span class="line">		&#125; </span><br><span class="line">		find(T-&gt;lchild,key);</span><br><span class="line">		find(T-&gt;rchild,key);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 同理可类似的写出中序和后序的代码 */</span></span><br></pre></td></tr></table></figure>

<h3 id="13-15）输出根结点到每个叶子结点的路径"><a href="#13-15）输出根结点到每个叶子结点的路径" class="headerlink" title="13.15）输出根结点到每个叶子结点的路径"></a>13.15）输出根结点到每个叶子结点的路径</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> top=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> pathstack[maxSize];<span class="comment">// 定义栈，这里采用先入栈然后 ++top 的方式，因此初值为 0</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">allPath</span><span class="params">(BTNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        pathstack[top]=p-&gt;data;<span class="comment">// 让第一次访问的结点入栈，即 p 自上至下走的时候结点入栈</span></span><br><span class="line">        ++top;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild==<span class="literal">NULL</span>&amp;&amp;p-&gt;rchild==<span class="literal">NULL</span>)&#123;<span class="comment">// 如果当前结点时叶子结点，则从栈底到栈顶打印路径</span></span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;top;++i)&#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;pathstack[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        allPath(p-&gt;lchild);</span><br><span class="line">        allPath(p-&gt;rchild);</span><br><span class="line">        --top;<span class="comment">// 第三次访问结点时出栈，即 p 自下至上走的时候结点出栈</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-16）计算二叉树形式的表达式的值"><a href="#13-16）计算二叉树形式的表达式的值" class="headerlink" title="13.16）计算二叉树形式的表达式的值"></a>13.16）计算二叉树形式的表达式的值</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">op</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">char</span> OP,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(OP == <span class="string">&#x27;+&#x27;</span>) &#123;<span class="keyword">return</span> a+b;&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(OP == <span class="string">&#x27;-&#x27;</span>) &#123;<span class="keyword">return</span> a-b;&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(OP == <span class="string">&#x27;*&#x27;</span>) &#123;<span class="keyword">return</span> a*b;&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(OP == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(b == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;b cannot be zero!&quot;</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> </span><br><span class="line">			<span class="keyword">return</span> a/b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">com</span><span class="params">(BTNode *T)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> A,B;</span><br><span class="line">	<span class="keyword">if</span>(T!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(T-&gt;lchild!=<span class="literal">NULL</span>&amp;&amp;T-&gt;rchild!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="comment">// 如果当前结点左右子树都非空，则此结点为表达式，用后序遍历方式求值</span></span><br><span class="line">			A = com(T-&gt;lchild);<span class="comment">// 后序遍历求出左子树的值，赋值给 A</span></span><br><span class="line">			B = com(T-&gt;rchild);<span class="comment">// 后序遍历求出右子树的值，赋值给 B</span></span><br><span class="line">			<span class="keyword">return</span> op(A,T-&gt;data,B);<span class="comment">// 根据以求得的 A 与 B 和当前结点的运算符求出整个表达式的值</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> T-&gt;data-<span class="string">&#x27;0&#x27;</span>;<span class="comment">// 如果当前结点的左右子树都为空，则此结点为数值，直接返回。注意字符型数字转化为整型数字</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">// 如果是空树，则表达式的值为 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-17）哈夫曼编码"><a href="#13-17）哈夫曼编码" class="headerlink" title="13.17）哈夫曼编码"></a>13.17）哈夫曼编码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HuffmanNode</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> weight;<span class="comment">// 权重</span></span><br><span class="line">	<span class="keyword">char</span> id;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">HuffmanNode</span> *<span class="title">left</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">HuffmanNode</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125;HuffmanNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速排序，将队列中的哈夫曼树结点根据权重排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_w</span><span class="params">(HuffmanNode *qu[],<span class="keyword">int</span> f,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	HuffmanNode *s;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> i=f,j=r;</span><br><span class="line">	<span class="keyword">if</span>(f&lt;r)&#123;</span><br><span class="line">		s=qu[f];</span><br><span class="line">		<span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">			<span class="keyword">while</span>(j&gt;i&amp;&amp;qu[j]-&gt;weight&gt;=s-&gt;weight) --j;</span><br><span class="line">			<span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">				qu[i]=qu[j];</span><br><span class="line">				++i;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span>(i&lt;j&amp;&amp;qu[i]-&gt;weight&lt;s-&gt;weight) ++i;</span><br><span class="line">			<span class="keyword">if</span>(i&lt;j)&#123;</span><br><span class="line">				qu[j]=qu[i];</span><br><span class="line">				--j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		qu[i]=s;</span><br><span class="line">		sort_w(qu,f,i<span class="number">-1</span>);</span><br><span class="line">		sort_w(qu,i+<span class="number">1</span>,r);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈夫曼编码</span></span><br><span class="line"><span class="function">HuffmanNode* <span class="title">HuffmanTree</span><span class="params">(<span class="keyword">int</span> node[],<span class="keyword">char</span> name[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	HuffmanNode *qu[maxSize],*s,*p,*q;<span class="comment">// 定义哈夫曼树结点类型的队列</span></span><br><span class="line">	<span class="keyword">int</span> rear=<span class="number">0</span>,front=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 结点初始化并加入队列</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">	&#123;</span><br><span class="line">		s=(HuffmanNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HuffmanNode));</span><br><span class="line">		s-&gt;weight=node[i];</span><br><span class="line">		s-&gt;id=name[i];</span><br><span class="line">		s-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">		s-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">		rear=(rear+<span class="number">1</span>)%maxSize;</span><br><span class="line">		qu[rear]=s;</span><br><span class="line">	&#125;</span><br><span class="line">	sort_w(qu,front+<span class="number">1</span>,rear);<span class="comment">// 按照权重为队列中的结点排序</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 关键代码</span></span><br><span class="line">	<span class="keyword">while</span>(rear!=front+<span class="number">1</span>)&#123;<span class="comment">// 队不空时</span></span><br><span class="line">		p=qu[++front];<span class="comment">// 取队头，即权重最小的两个结点</span></span><br><span class="line">		q=qu[++front];</span><br><span class="line"></span><br><span class="line">		s=(HuffmanNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HuffmanNode));<span class="comment">// 创建新结点</span></span><br><span class="line">		s-&gt;left=p;<span class="comment">// 新结点左右孩子分别为队中取出的两结点</span></span><br><span class="line">		s-&gt;right=q;</span><br><span class="line">		s-&gt;weight=p-&gt;weight+q-&gt;weight;<span class="comment">// 权重为两结点之和</span></span><br><span class="line">		rear=(rear+<span class="number">1</span>)%maxSize;<span class="comment">// 新结点入队</span></span><br><span class="line">		qu[rear]=s;</span><br><span class="line">		sort_w(qu,front+<span class="number">1</span>,rear);<span class="comment">// 重新根据权重排序</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> qu[rear];<span class="comment">// 返回最后队尾元素，即哈夫曼树根结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="14- 图的存储结构"><a href="#14- 图的存储结构" class="headerlink" title="14. 图的存储结构"></a>14. 图的存储结构</h2><h3 id="14-1）邻接矩阵的结点定义"><a href="#14-1）邻接矩阵的结点定义" class="headerlink" title="14.1）邻接矩阵的结点定义"></a>14.1）邻接矩阵的结点定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> no;  <span class="comment">// 顶点编号</span></span><br><span class="line">    <span class="keyword">char</span> info;  <span class="comment">// 顶点的其他信息，这里默认为 char 型。这一句一般在题目中很少用到，因此题目不做特殊要求可以不写</span></span><br><span class="line">&#125;VertexType;  <span class="comment">// 顶点类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	VertexType vex[maxSize];<span class="comment">// 存放顶点的数组</span></span><br><span class="line">	<span class="keyword">int</span> edges[maxSize][maxSize];<span class="comment">// 邻接矩阵的定义</span></span><br><span class="line">	<span class="keyword">int</span> n, e;<span class="comment">// 顶点数与边数</span></span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure>

<h3 id="14-2）邻接表的结点定义"><a href="#14-2）邻接表的结点定义" class="headerlink" title="14.2）邻接表的结点定义"></a>14.2）邻接表的结点定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> adjvex;<span class="comment">// 该边的邻接点</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> *<span class="title">nextarc</span>;</span><span class="comment">// 指向下一条边的指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span> data;</span><br><span class="line">	ArcNode *firstarc;<span class="comment">// 指向第一条边的指针</span></span><br><span class="line">&#125;VNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	VNode adjlist[maxSize];<span class="comment">// 邻接表</span></span><br><span class="line">	<span class="keyword">int</span> n, e;<span class="comment">// 顶点数和边数</span></span><br><span class="line">&#125;AGraph;</span><br></pre></td></tr></table></figure>

<h2 id="15- 图的遍历与应用"><a href="#15- 图的遍历与应用" class="headerlink" title="15. 图的遍历与应用"></a>15. 图的遍历与应用</h2><h3 id="15-1）图的深度优先遍历 DFS"><a href="#15-1）图的深度优先遍历 DFS" class="headerlink" title="15.1）图的深度优先遍历 DFS"></a>15.1）图的深度优先遍历 DFS</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图的深度优先遍历 DFS</span></span><br><span class="line"><span class="keyword">int</span> visited[maxSize];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(AGraph *G, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">	ArcNode *p;</span><br><span class="line">	visit(G, v);<span class="comment">// 首先访问传入的起始顶点</span></span><br><span class="line">	visited[v] = <span class="number">1</span>;<span class="comment">// 置已访问标志</span></span><br><span class="line">	p = G-&gt;adjlist[v].firstarc;<span class="comment">//p 指向该顶点的第一个邻接点</span></span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (visited[p-&gt;adjvex] == <span class="number">0</span>) <span class="comment">// 若顶点未被访问，则递归访问它</span></span><br><span class="line">		&#123;</span><br><span class="line">			DFS(G, p-&gt;adjvex);</span><br><span class="line">			p = p-&gt;nextarc;<span class="comment">//p 指向下一条边的邻接点</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-2）图的广度优先遍历 BFS"><a href="#15-2）图的广度优先遍历 BFS" class="headerlink" title="15.2）图的广度优先遍历 BFS"></a>15.2）图的广度优先遍历 BFS</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图的广度优先遍历 BFS</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(AGraph *G, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">	ArcNode *p;</span><br><span class="line">	<span class="keyword">int</span> que[maxSize], front = <span class="number">0</span>, rear = <span class="number">0</span>;<span class="comment">// 定义一个队列</span></span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	visit(G, v);<span class="comment">// 访问起始顶点</span></span><br><span class="line">	visited[v] = <span class="number">1</span>;<span class="comment">// 置已访问标记</span></span><br><span class="line">	rear = (rear + <span class="number">1</span>) % maxSize;<span class="comment">// 访问顶点入队</span></span><br><span class="line">	que[rear] = v;</span><br><span class="line">	<span class="keyword">while</span> (front != rear)<span class="comment">// 队列为空说明遍历结束</span></span><br><span class="line">	&#123;</span><br><span class="line">		front = (front + <span class="number">1</span>) % maxSize;<span class="comment">// 对顶出队</span></span><br><span class="line">		j = que[front];</span><br><span class="line">		p = G-&gt;adjlist[j].firstarc;<span class="comment">//p 指向对顶顶点第一条边</span></span><br><span class="line">		<span class="keyword">while</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (visited[p-&gt;adjvex] == <span class="number">0</span>) <span class="comment">// 若当前邻接点未被访问。则访问并入队</span></span><br><span class="line">			&#123;</span><br><span class="line">				visit(G, p-&gt;adjvex);</span><br><span class="line">				visited[p-&gt;adjvex] = <span class="number">1</span>;</span><br><span class="line">				rear = (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">				que[rear] = p-&gt;adjvex;</span><br><span class="line">			&#125;</span><br><span class="line">			p = p-&gt;nextarc;<span class="comment">//p 指向 j 的下一条边</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-3）求不带权连通图中距点 v 最远点"><a href="#15-3）求不带权连通图中距点 v 最远点" class="headerlink" title="15.3）求不带权连通图中距点 v 最远点"></a>15.3）求不带权连通图中距点 v 最远点</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在广度优先代码上加个返回值即可。因为广度优先遍历最后访问的顶点就是最远的</span></span><br></pre></td></tr></table></figure>

<h3 id="15-4）判断无向图是否为一棵树"><a href="#15-4）判断无向图是否为一棵树" class="headerlink" title="15.4）判断无向图是否为一棵树"></a>15.4）判断无向图是否为一棵树 </h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> visit[maxSize];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(AGraph *G,<span class="keyword">int</span> v,<span class="keyword">int</span> &amp;vn,<span class="keyword">int</span> &amp;en)</span></span>&#123;</span><br><span class="line">	ArcNode *s;</span><br><span class="line">	visit[v]=<span class="number">1</span>;</span><br><span class="line">	++vn;<span class="comment">// 针对本题，对当前图的顶点访问，则计数器 vn 自增 1</span></span><br><span class="line">	s=G-&gt;adjlist[v].first;<span class="comment">//s 指向边结点</span></span><br><span class="line">	<span class="keyword">while</span>(s!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">		++en;<span class="comment">// 边树计数器 en 自增 1</span></span><br><span class="line">		<span class="keyword">if</span>(visit[s-&gt;adjvex]==<span class="number">0</span>)</span><br><span class="line">			DFS(G,s-&gt;adjvex,vn,en);</span><br><span class="line">		s=s-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isTree</span><span class="params">(AGraph *G)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> vn=<span class="number">0</span>,en=<span class="number">0</span>,i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;n;++i)</span><br><span class="line">		visit[i]=<span class="number">0</span>;<span class="comment">//visit[] 数组初始化</span></span><br><span class="line">	DFS(G,<span class="number">1</span>,vn,en);<span class="comment">// 遍历</span></span><br><span class="line">	<span class="comment">// 如果遍历过程中访问过的顶点数和给定图的顶点数相等，且边数等于顶点数减 1，则证明是树，返回 1，否则返回 0</span></span><br><span class="line">	<span class="keyword">if</span>(vn==G-&gt;n&amp;&amp;G-&gt;n<span class="number">-1</span>==en/<span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-5）分别用 BFS、DFS 判断图中点 i、j 是否连通"><a href="#15-5）分别用 BFS、DFS 判断图中点 i、j 是否连通" class="headerlink" title="15.5）分别用 BFS、DFS 判断图中点 i、j 是否连通"></a>15.5）分别用 BFS、DFS 判断图中点 i、j 是否连通 </h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFSTrave</span><span class="params">(AGraph *G,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">	<span class="comment">//int visit[maxSize];</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;G-&gt;n;++k) visit[k]=<span class="number">0</span>;<span class="comment">// 初始化 visit[] 数组 </span></span><br><span class="line">	DFS(G,i);<span class="comment">// 这里换成 &quot;BFS(G,i);&quot; 也可以</span></span><br><span class="line">	<span class="keyword">if</span> (visit[j]==<span class="number">1</span>)<span class="comment">//visit[j] 等于 1 则证明了访问过程中遇到了 j</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-6）判断有向图 G 是否有根"><a href="#15-6）判断有向图 G 是否有根" class="headerlink" title="15.6）判断有向图 G 是否有根"></a>15.6）判断有向图 G 是否有根</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在深度优先遍历代码上加个计数器即可。若遍历后计数器等于图中顶点总数则为根</span></span><br></pre></td></tr></table></figure>

<h2 id="16- 最小（代价）生成树"><a href="#16- 最小（代价）生成树" class="headerlink" title="16. 最小（代价）生成树"></a>16. 最小（代价）生成树</h2><h3 id="16-1）Prim 算法"><a href="#16-1）Prim 算法" class="headerlink" title="16.1）Prim 算法"></a>16.1）Prim 算法</h3><p><img data-src="/archives/9ced5463/20210813141715940.png"></p>
<p><strong>普里姆算法的实现思路是</strong>：</p>
<ol>
<li>将连通网中的所有顶点分为两类（假设为 A 类和 B 类）。A 类表示已并入最小生成树的点的集合，B 类表示未并入最小生成树的点的集合。初始状态下，所有顶点位于 B 类；</li>
<li>选择任意一个顶点，将其从 B 类移动到 A 类；</li>
<li>从 B 类的所有顶点出发，找出一条连接着 A 类中的某个顶点且权值最小的边，将此边连接着的 B 类中的顶点移动到 A 类；</li>
<li>重复执行第 3 步，直至 B 类中的所有顶点全部移动到 A 类，恰好可以找到 N-1 条边。</li>
</ol>
<p>举个例子，下图是一个连通网，使用普里姆算法查找最小生成树，需经历以下几个过程：</p>
<p><img data-src="/archives/9ced5463/1454315049-0.gif" alt="img"><br>图 1 连通网</p>
<ol>
<li><p>将图中的所有顶点分为 A 类和 B 类，初始状态下，A = {}，B = {A, B, C, D, S, T}。</p>
</li>
<li><p>从 B 类中任选一个顶点，假设选择 S 顶点，将其从 B 类移到 A 类，A = {S}，B = {A, B, C, D, T}。从 A 类的 S 顶点出发，到达 B 类中顶点的边有 2 个，分别是 S-A 和 S-C，其中 S-A 边的权值最小，所以选择 S-A 边组成最小生成树，将 A 顶点从 B 类移到 A 类，A = {S, A}，B = {B, C, D, T}。</p>
</li>
</ol>
<p><img data-src="/archives/9ced5463/1454311B6-1.gif" alt="img"><br>图 2 S-A 边组成最小生成树</p>
<ol start="3">
<li>从 A 类中的 S、A 顶点出发，到达 B 类中顶点的边有 3 个，分别是 S-C、A-C、A-B，其中 A-C 的权值最小，所以选择 A-C 组成最小生成树，将顶点 C 从 B 类移到 A 类，A = {S, A, C}，B = {B, D, T}。</li>
</ol>
<p><img data-src="/archives/9ced5463/145431BB-2.gif" alt="img"><br>图 3 A-C 边组成最小生成树</p>
<ol start="4">
<li>从 A 类中的 S、A、C 顶点出发，到达 B 类顶点的边有 S-C、A-B、C-B、C-D，其中 C-D 边的权值最小，所以选择 C-D 组成最小生成树，将顶点 D 从 B 类移到 A 类，A = {S, A, C, D}，B = {B, T}。</li>
</ol>
<p><img data-src="/archives/9ced5463/1454314421-3.gif" alt="img"><br>图 4 C-D 边组成最小生成树</p>
<ol start="5">
<li>从 A 类中的 S、A、C、D 顶点出发，到达 B 类顶点的边有 A-B、C-B、D-B、D-T，其中 D-B 和 D-T 的权值最小，任选其中的一个，例如选择 D-B 组成最小生成树，将顶点 B 从 B 类移到 A 类，A = {S, A, C, D, B}，B = {T}。</li>
</ol>
<p><img data-src="/archives/9ced5463/1454315601-4.gif" alt="img"><br>图 5 D-B 边组成最小生成树</p>
<ol start="6">
<li>从 A 类中的 S、A、C、D、B 顶点出发，到达 B 类顶点的边有 B-T、D-T，其中 D-T 的权值最小，选择 D-T 组成最小生成树，将顶点 T 从 B 类移到 A 类，A = {S, A, C, D, B, T}，B = {}。</li>
</ol>
<p><img data-src="/archives/9ced5463/145431L19-5.gif" alt="img"><br>图 6 D-T 边组成最小生成树</p>
<ol start="7">
<li>由于 B 类中的顶点全部移到了 A 类，因此 S-A、A-C、C-D、D-B、D-T 组成的是一个生成树，而且是一个最小生成树，它的总权值为 17。</li>
</ol>
<p><img data-src="/archives/9ced5463/1454313005-6.gif" alt="img"><br>图 7 最小生成树</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Prim</span><span class="params">(MGraph g, <span class="keyword">int</span> v0, <span class="keyword">int</span> &amp;sum)</span> </span>&#123;<span class="comment">//sum 为最小生成树的总权值 </span></span><br><span class="line">    <span class="keyword">int</span> lowcost[maxSize], vset[maxSize], v;</span><br><span class="line">    <span class="comment">//lowcost[] 数组记录了当前已并入最小生成树的顶点到所有未并入生成树的最小权值；</span></span><br><span class="line">    <span class="comment">//vset[]数组记录当前顶点是否已被并入最小生成树，并入了值设为 1，未并入设为 0；</span></span><br><span class="line">    <span class="comment">// 变量 v 用来始终指向刚并入的顶点</span></span><br><span class="line">    <span class="keyword">int</span> i, j, k, min;<span class="comment">//min 变量用来寻找满足条件的最短的边</span></span><br><span class="line">    v = v0;<span class="comment">// 初始 v 指向 v0</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g.n; ++i) &#123;</span><br><span class="line">        lowcost[i] = g.edges[v0][i];<span class="comment">// 初始化，lowcost 数组为 v0 顶点到其他所有顶点的权值</span></span><br><span class="line">        vset[i] = <span class="number">0</span>;<span class="comment">// 初始化，vset 数组全部设为 0，即还没有顶点并入最小生成树中</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vset[v0] = <span class="number">1</span>;  <span class="comment">// 将 v0 并入树中</span></span><br><span class="line">    sum = <span class="number">0</span>;  <span class="comment">// sum 清零用来累计树的权值</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g.n<span class="number">-1</span>; ++i) &#123;<span class="comment">// 找最小生成树的边，n 个结点需要找 n-1 条边</span></span><br><span class="line">        min = INF;  <span class="comment">// INF 是一个已经定义的比图中所有边权值都大的常量</span></span><br><span class="line">        <span class="comment">// 下面这个循环用于选出候选边中的最小者，并将此边的另一头顶点加入最小生成树</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; g.n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vset[j] == <span class="number">0</span> &amp;&amp; lowcost[j] &lt; min) &#123;  </span><br><span class="line">                <span class="comment">// 选出当前生成树其他顶点到最短边中最短的一条</span></span><br><span class="line">                min = lowcost[j]；</span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">            vset[k] = <span class="number">1</span>;<span class="comment">// 将最短边的另一头顶点加入最小生成树</span></span><br><span class="line">            v = k;<span class="comment">//v 指向新并入的顶点</span></span><br><span class="line">            sum += min;  <span class="comment">// 这里用 sum 记录了最小生成树的权值</span></span><br><span class="line">            <span class="comment">// 下面这个循环以刚进入的顶点 v 为媒介更新候选边 lowcost 数组</span></span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; g.n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (vset[j] == <span class="number">0</span> &amp;&amp; g.edges[v][j] &lt; lowcost[j]) &#123;</span><br><span class="line">                    lowcost[j] = g.edges[v][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="16-2）Kruskal 算法"><a href="#16-2）Kruskal 算法" class="headerlink" title="16.2）Kruskal 算法"></a>16.2）Kruskal 算法</h3><p><img data-src="/archives/9ced5463/20210813141738863-1633050039218.png"></p>
<p><strong>克鲁斯卡尔算法查找最小生成树的方法是：</strong></p>
<p>将连通网中所有的边按照权值大小做升序排序，从权值最小的边开始选择，只要此边不和已选择的边一起构成环路，就可以选择它组成最小生成树。对于 N 个顶点的连通网，挑选出 N-1 条符合条件的边，这些边组成的生成树就是最小生成树。</p>
<p>举个例子，图 1 是一个连通网，克鲁斯卡尔算法查找图 1 对应的最小生成树，需要经历以下几个步骤：</p>
<p><img data-src="/archives/9ced5463/145G46133-0.gif" alt="img"><br>图 1 连通网</p>
<ol>
<li>将连通网中的所有边按照权值大小做升序排序：</li>
</ol>
<p><img data-src="/archives/9ced5463/145G44143-1.gif" alt="img"></p>
<ol start="2">
<li>从 B-D 边开始挑选，由于尚未选择任何边组成最小生成树，且 B-D 自身不会构成环路，所以 B-D 边可以组成最小生成树。</li>
</ol>
<p><img data-src="/archives/9ced5463/145G41F4-2.gif" alt="img"><br>图 2 B-D 边组成最小生成树</p>
<ol start="3">
<li>D-T 边不会和已选 B-D 边构成环路，可以组成最小生成树：</li>
</ol>
<p><img data-src="/archives/9ced5463/145G4D41-3.gif" alt="img"><br>图 3 D-T 边组成最小生成树</p>
<ol start="4">
<li>A-C 边不会和已选 B-D、D-T 边构成环路，可以组成最小生成树：</li>
</ol>
<p><img data-src="/archives/9ced5463/145G44336-4.gif" alt="img"><br>图 4 A-C 边组成最小生成树</p>
<ol start="5">
<li>C-D 边不会和已选 A-C、B-D、D-T 边构成环路，可以组成最小生成树：</li>
</ol>
<p><img data-src="/archives/9ced5463/145G4CN-5.gif" alt="img"><br>图 5 C-D 边组成最小生成树</p>
<ol start="6">
<li>C-B 边会和已选 C-D、B-D 边构成环路，因此不能组成最小生成树：</li>
</ol>
<p><img data-src="/archives/9ced5463/145G44357-6.gif" alt="img"><br>图 6 C-B 边不能组成最小生成树</p>
<ol start="7">
<li>B-T 、A-B、S-A 三条边都会和已选 A-C、C-D、B-D、D-T 构成环路，都不能组成最小生成树。而 S-A 不会和已选边构成环路，可以组成最小生成树。</li>
</ol>
<p><img data-src="/archives/9ced5463/145G45057-7.gif" alt="img"><br>图 7 S-A 边组成最小生成树</p>
<ol start="8">
<li>如图 7 所示，对于一个包含 6 个顶点的连通网，我们已经选择了 5 条边，这些边组成的生成树就是最小生成树。</li>
</ol>
<p><img data-src="/archives/9ced5463/145G4M94-8.gif" alt="img"><br>图 8 最小生成树</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b;  <span class="comment">// a 和 b 为一条边所连的两个顶点</span></span><br><span class="line">    <span class="keyword">int</span> w;  <span class="comment">// 边的权值</span></span><br><span class="line">&#125;Road;</span><br><span class="line">Road road[maxSize];</span><br><span class="line"><span class="keyword">int</span> v[maxSize];  <span class="comment">// 定义并查集数组（连通分量）；类似树的双亲存储结构，数组值是双亲顶点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getRoot</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123; <span class="comment">// 在并查集中查找根结点的函数</span></span><br><span class="line">    <span class="keyword">while</span> (a != v[a])  a = v[a]; <span class="comment">// 只有根结点双亲是其自己</span></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Kruskal</span><span class="params">(MGraph g, <span class="keyword">int</span> &amp;sum, Road road[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, N, E, a, b;</span><br><span class="line">    N = g.n;<span class="comment">// 顶点数</span></span><br><span class="line">    E = g.e;<span class="comment">// 边数</span></span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; ++i)  v[i] = i;<span class="comment">// 初始化，每一个顶点都看作是一个连通分量</span></span><br><span class="line">    sort(road, E);   <span class="comment">// 对 road 数组中的 E 条边按其权值从小到大排序, 假设该函数已定义好</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; E; ++i) &#123;<span class="comment">// 循环每条边</span></span><br><span class="line">        a = getRoot(road[i].a);<span class="comment">// 寻找该边一端顶点的连通分量的根结点</span></span><br><span class="line">        b = getRoot(road[i].b);<span class="comment">// 寻找该边另一端顶点的连通分量的根结点</span></span><br><span class="line">        <span class="keyword">if</span> (a != b) &#123;<span class="comment">// 该边的两端顶点不在一个连通分量上，符合条件</span></span><br><span class="line">            v[a] = b;<span class="comment">// 连接两个连通分量</span></span><br><span class="line">            sum += road[i].w;<span class="comment">// 权重累加</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="17- 最短路径算法"><a href="#17- 最短路径算法" class="headerlink" title="17. 最短路径算法"></a>17. 最短路径算法</h2><h3 id="17-1）Dijkstra 算法"><a href="#17-1）Dijkstra 算法" class="headerlink" title="17.1）Dijkstra 算法"></a>17.1）Dijkstra 算法</h3><p><img data-src="/archives/9ced5463/20210813141818125-1633050039220.png"></p>
<p><img data-src="/archives/9ced5463/2021081314182741-1633050039221.png"></p>
<p><img data-src="/archives/9ced5463/image-20210929101337540.png"></p>
<p><strong>最短路径算法 - 迪杰斯特拉 (Dijkstra) 算法</strong></p>
<p>迪杰斯特拉 (Dijkstra) 算法是典型最短路径算法，用于计算一个节点到其他节点的最短路径。<br>它的主要特点是以起始点为中心向外层层扩展(广度优先遍历思想)，直到扩展到终点为止。</p>
<p><strong>基本思想</strong></p>
<ol>
<li>通过 Dijkstra 计算图 G 中的最短路径时，需要指定一个起点 D(即从顶点 D 开始计算)。</li>
<li>此外，引进两个数组 S 和 U。S 的作用是记录已求出最短路径的顶点(以及相应的最短路径长度)，而 U 则是记录还未求出最短路径的顶点(以及该顶点到起点 D 的距离)。</li>
<li>初始时，数组 S 中只有起点 D；数组 U 中是除起点 D 之外的顶点，并且数组 U 中记录各顶点到起点 D 的距离。如果顶点与起点 D 不相邻，距离为无穷大。</li>
<li>然后，从数组 U 中找出路径最短的顶点 K，并将其加入到数组 S 中；同时，从数组 U 中移除顶点 K。接着，更新数组 U 中的各顶点到起点 D 的距离。</li>
<li>重复第 4 步操作，直到遍历完所有顶点。</li>
</ol>
<p> <strong>迪杰斯特拉 (Dijkstra) 算法图解</strong></p>
<p><img data-src="/archives/9ced5463/v2-cdd360483874245e65eb96c8374b598c_720w.jpg" alt="img"></p>
<p>以上图为例，来对迪杰斯特拉进行算法演示(以顶点 D 为起点)。</p>
<p><img data-src="/archives/9ced5463/v2-d29190c3a51249cbbc0be5ed8ebb7c13_720w.jpg" alt="img"></p>
<p><strong>初始状态 </strong>：S 是已计算出最短路径的顶点集合，U 是未计算除最短路径的顶点的集合！<br><strong> 第 1 步 </strong>：将顶点 D 加入到 S 中。<br> 此时，S={D(0)}, U={A(∞),B(∞),C(3),E(4),F(∞),G(∞)}。 注:C(3)表示 C 到起点 D 的距离是 3。</p>
<p><strong>第 2 步 </strong>：将顶点 C 加入到 S 中。<br> 上一步操作之后，U 中顶点 C 到起点 D 的距离最短；因此，将 C 加入到 S 中，同时更新 U 中顶点的距离。以顶点 F 为例，之前 F 到 D 的距离为∞；但是将 C 加入到 S 之后，F 到 D 的距离为 9=(F,C)+(C,D)。<br>此时，S={D(0),C(3)}, U={A(∞),B(13),E(4),F(9),G(∞)}。</p>
<p><strong>第 3 步 </strong>：将顶点 E 加入到 S 中。<br> 上一步操作之后，U 中顶点 E 到起点 D 的距离最短；因此，将 E 加入到 S 中，同时更新 U 中顶点的距离。还是以顶点 F 为例，之前 F 到 D 的距离为 9；但是将 E 加入到 S 之后，F 到 D 的距离为 6=(F,E)+(E,D)。<br>此时，S={D(0),C(3),E(4)}, U={A(∞),B(13),F(6),G(12)}。</p>
<p><strong>第 4 步 </strong>：将顶点 F 加入到 S 中。<br> 此时，S={D(0),C(3),E(4),F(6)}, U={A(22),B(13),G(12)}。</p>
<p><strong>第 5 步 </strong>：将顶点 G 加入到 S 中。<br> 此时，S={D(0),C(3),E(4),F(6),G(12)}, U={A(22),B(13)}。</p>
<p><strong>第 6 步 </strong>：将顶点 B 加入到 S 中。<br> 此时，S={D(0),C(3),E(4),F(6),G(12),B(13)}, U={A(22)}。</p>
<p><strong>第 7 步 </strong>：将顶点 A 加入到 S 中。<br> 此时，S={D(0),C(3),E(4),F(6),G(12),B(13),A(22)}。</p>
<p>此时，起点 D 到各个顶点的最短距离就计算出来了：**A(22) B(13) C(3) D(0) E(4) F(6) G(12)**。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(MGraph g, <span class="keyword">int</span> v, <span class="keyword">int</span> dist[], <span class="keyword">int</span> path[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">//dist[]数组存储当前已并入顶点到其余未并入顶点的最短路径长度 </span></span><br><span class="line">    <span class="comment">//path[] 数组存储起点到其余各顶点最短路径，类似树的双亲存储结构，数组内的值为该顶点双亲的值 </span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">set</span>[maxSize];<span class="comment">//set[] 数组标记哪些顶点已被选入最短路径</span></span><br><span class="line">    <span class="keyword">int</span> min, i, j, u;<span class="comment">//min 用来辅助寻找哪条路径最短</span></span><br><span class="line">    <span class="comment">// 从这句开始对各数组进行初始化</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g.n; ++i) &#123;</span><br><span class="line">        dist[i] = g.edges[v][i];<span class="comment">// 初始时 dist 为初始顶点到各个顶点的距离</span></span><br><span class="line">        <span class="built_in">set</span>[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (g.edges[v][i] &lt; INF)</span><br><span class="line">            path[i] = v;<span class="comment">// 如果当前顶点与初始顶点距离非无穷（即与初始顶点直接相连），则 path 值设为初始顶点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            path[i] = <span class="number">-1</span>;<span class="comment">// 否则的话（此顶点与初始顶点距离无穷或者它就是初始顶点），path 值设为 -1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">set</span>[v] = <span class="number">1</span>; path[v] = <span class="number">-1</span>;<span class="comment">// 将初始顶点并入最短路径顶点集合</span></span><br><span class="line">    <span class="comment">//  初始化结束</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关键操作开始</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g.n<span class="number">-1</span>; ++i) &#123;<span class="comment">// 除去初始顶点，要将剩余 n-1 个顶点依次并入最短路径集合</span></span><br><span class="line">        min = INF;</span><br><span class="line">        <span class="comment">// 这个循环每次从剩余顶点中选出一个顶点，通往这个顶点的路径在通往所有剩余顶点的路径中是长度最短的</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; g.n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">set</span>[j] == <span class="number">0</span> &amp;&amp; dist[j] &lt; min) &#123;</span><br><span class="line">                u = j;</span><br><span class="line">                min = dist[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">set</span>[u] = <span class="number">1</span>;  <span class="comment">// 将选出的顶点并入最短路径中</span></span><br><span class="line">        <span class="comment">// 这个循环以刚并入的顶点作为中间点，对所有通往剩余顶点的路径进行检测</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; g.n; ++j) &#123;</span><br><span class="line">            <span class="comment">// 这个 if 语句判断顶点 u 的加入是否为出现通往顶点 j 的更短的路径</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">set</span>[j] == <span class="number">0</span> &amp;&amp; dist[u]+g.edges[u][j] &lt; dist[j]) &#123;</span><br><span class="line">                dist[j] = dist[u] + g.edges[u][j];</span><br><span class="line">                path[j] = u;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17-2）Floyd 算法"><a href="#17-2）Floyd 算法" class="headerlink" title="17.2）Floyd 算法"></a>17.2）Floyd 算法</h3><p><img data-src="/archives/9ced5463/20210813141902545.png"></p>
<p>1)算法思想原理：</p>
<p>   Floyd 算法是一个经典的动态规划算法。用通俗的语言来描述的话，首先我们的目标是寻找从点 i 到点 j 的最短路径。从动态规划的角度看问题，我们需要为这个目标重新做一个诠释（这个诠释正是动态规划最富创造力的精华所在）</p>
<p>   从任意节点 i 到任意节点 j 的最短路径不外乎 2 种可能，1 是直接从 i 到 j，2 是从 i 经过若干个节点 k 到 j。所以，我们假设 Dis(i,j)为节点 u 到节点 v 的最短路径的距离，对于每一个节点 k，我们检查 Dis(i,k) + Dis(k,j) &lt; Dis(i,j)是否成立，如果成立，证明从 i 到 k 再到 j 的路径比 i 直接到 j 的路径短，我们便设置 Dis(i,j) = Dis(i,k) + Dis(k,j)，这样一来，当我们遍历完所有节点 k，Dis(i,j)中记录的便是 i 到 j 的最短路径的距离。</p>
<p>2). 算法描述：</p>
<p>a. 从任意一条单边路径开始。所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大。 　　</p>
<p>b. 对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短。如果是更新它。</p>
<p>弗洛伊德算法是基于 <a target="_blank" rel="external nofollow noopener noreferrer" href="http://c.biancheng.net/algorithm/dynamic-programming.html"> 动态规划算法 </a> 实现的，接下来我们以在图 1 所示的有向加权图中查找各个顶点之间的最短路径为例，讲解弗洛伊德算法的实现思路。</p>
<p><img data-src="/archives/9ced5463/1502393Y3-0.gif" alt="img"><br>图 1 有向加权图</p>
<blockquote>
<p>图 1 中不存在环路，且所有路径（边）的权值都为正数，因此可以使用弗洛伊德算法。</p>
</blockquote>
<p>弗洛伊德算法查找图 1 中各个顶点之间的最短路径，实现过程如下：</p>
<ol>
<li>建立一张表格，记录每个顶点直达其它所有顶点的权值：</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>目标顶点</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td></td>
<td></td>
</tr>
<tr>
<td>起始顶点</td>
<td>1</td>
<td>0</td>
<td>3</td>
<td>∞</td>
<td>5</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>0</td>
<td>∞</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>∞</td>
<td>1</td>
<td>0</td>
<td>∞</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>∞</td>
<td>∞</td>
<td>2</td>
<td>0</td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>起始顶点指的是从哪个顶点出发，目标顶点指的是要达到的顶点，例如 2-&gt;1 路径的权值是 2，顶点 2 是起始顶点，顶点 1 是目标顶点。此外，∞ 表示无穷大的数，即顶点之间不存在直达的路径。</p>
</blockquote>
<ol start="2">
<li>在表 1 的基础上，将顶点 1 作为 “中间顶点”，计算从各个顶点出发途径顶点 1 再到达其它顶点的权值，如果比表 1 中记录的权值更小，证明两个顶点之间存在更短的路径，对表 1 进行更新。</li>
</ol>
<p>从各个顶点出发，途径顶点 1 再到达其它顶点的路径以及对应的权值分别是：</p>
<ul>
<li>2-1-3：权值为 2 + ∞ = ∞，表 1 中记录的 2-3 的权值也是 ∞；</li>
<li>2-1-4：权值为 2 + 5 = 7，表 1 中记录的 2-4 的权值是 4；</li>
<li>3-1-2：权值为 ∞ + 3，表 1 中记录的 3-2 的权值是 1；</li>
<li>3-1-4：权值为 ∞ + 5，表 1 中记录的 3-4 的权值是 ∞；</li>
<li>4-1-2：权值为 ∞ + 3，表 1 中记录的 4-2 的权值是 ∞；</li>
<li>4-1-3：权值为 ∞ + ∞，表 1 中记录的 4-3 的权值是 2。 </li>
</ul>
<p>以上所有的路径中，没有比表 1 中记录的权值最小的路径，所以不需要对表 1 进行更新。</p>
<ol start="3">
<li>在表 1 的基础上，以顶点 2 作为 “中间顶点”，计算从各个顶点出发途径顶点 2 再到达其它顶点的权值：</li>
</ol>
<ul>
<li>1-2-3：权值为 3 + ∞，表 1 中记录的 1-3 的权值为 ∞；</li>
<li>1-2-4：权值为 3 + 4 = 7，表 1 中 1-4 的权值为 5；</li>
<li>3-2-1：权值为 1 + 2 = 3，表 1 中 3-1 的权值为 ∞，3 &lt; ∞；</li>
<li>3-2-4：权值为 1 + 4 = 5，表 1 中 3-4 的权值为 ∞，5 &lt; ∞；</li>
<li>4-2-1：权值为 ∞ + 2，表 1 中 4-1 的权值为 ∞；</li>
<li>4-2-3：权值为 ∞ + ∞，表 1 中 4-3 的权值为 2。</li>
</ul>
<p>以顶点 2 作为 “中间顶点”，我们找到了比 3-1、3-4 更短的路径，对表 1 进行更新：</p>
<table>
<thead>
<tr>
<th></th>
<th>目标顶点</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td></td>
<td></td>
</tr>
<tr>
<td>起始顶点</td>
<td>1</td>
<td>0</td>
<td>3</td>
<td>∞</td>
<td>5</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>0</td>
<td>∞</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>3（3-2-1）</td>
<td>1</td>
<td>0</td>
<td>5（3-2-4）</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>∞</td>
<td>∞</td>
<td>2</td>
<td>0</td>
<td></td>
</tr>
</tbody></table>
<ol start="4">
<li>在表 2 的基础上，将顶点 3 作为 “中间顶点”，计算从各个顶点出发途径顶点 3 再到达其它顶点的权值：</li>
</ol>
<ul>
<li>1-3-2 权值为 ∞ + 1，表 2 中 1-2 的权值为 3；</li>
<li>1-3-4 权值为 ∞ + 5，表 2 中 1-4 的权值为 5；</li>
<li>2-3-1 权值为 ∞ + 3，表 2 中 2-1 的权值为 2；</li>
<li>2-3-4 权值为 ∞ + 5，表 2 中 2-4 的权值为 4；</li>
<li>4-3-1 权值为 2 + 3 = 5，表 2 中 4-1 的权值为 ∞，5 &lt; ∞；</li>
<li>4-3-2 权值为 2 + 1 = 3，表 2 中 4-2 的权值为 ∞，3 &lt; ∞；</li>
</ul>
<p>以顶点 3 作为 “中间顶点”，我们找到了比 4-1、4-2 更短的路径，对表 2 进行更新：</p>
<table>
<thead>
<tr>
<th></th>
<th>目标顶点</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td></td>
<td></td>
</tr>
<tr>
<td>起始顶点</td>
<td>1</td>
<td>0</td>
<td>3</td>
<td>∞</td>
<td>5</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>0</td>
<td>∞</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>3（3-2-1）</td>
<td>1</td>
<td>0</td>
<td>5（3-2-4）</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>5（4-3-2-1）</td>
<td>3（4-3-2）</td>
<td>2</td>
<td>0</td>
<td></td>
</tr>
</tbody></table>
<ol start="5">
<li>在表 3 的基础上，将顶点 4 作为 “中间顶点”，计算从各个顶点出发途径顶点 4 再到达其它顶点的权值：</li>
</ol>
<ul>
<li>1-4-2 权值为 5 + 3 = 8，表 3 中 1-2 的权值为 3；</li>
<li>1-4-3 权值为 5 + 2 = 7，表 3 中 1-3 的权值为 ∞，7 &lt; ∞；</li>
<li>2-4-1 权值为 4 + 5 = 9，表 3 中 2-1 的权值为 2；</li>
<li>2-4-3 权值为 4 + 2 = 6，表 3 中 2-3 的权值为 ∞，6 &lt; ∞；</li>
<li>3-4-1 权值为 4 + 5 = 9，表 3 中 3-1 的权值为 3；</li>
<li>3-4-2 权值为 5 + 5 = 10 ，表 3 中 3-2 的权值为 1。</li>
</ul>
<p>以顶点 4 作为 “中间顶点”，我们找到了比 1-3、2-3 更短的路径，对表 3 进行更新：</p>
<table>
<thead>
<tr>
<th></th>
<th>目标顶点</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td></td>
<td></td>
</tr>
<tr>
<td>起始顶点</td>
<td>1</td>
<td>0</td>
<td>3</td>
<td>7（1-4-3）</td>
<td>5</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>0</td>
<td>6（2-4-3）</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>3（3-2-1）</td>
<td>1</td>
<td>0</td>
<td>5（3-2-4）</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>5（4-3-2-1）</td>
<td>3（4-3-2）</td>
<td>2</td>
<td>0</td>
<td></td>
</tr>
</tbody></table>
<p>通过将所有的顶点分别作为“中间顶点”，最终得到的表 4 就记录了各个顶点之间的最短路径。例如，4-1 的最短路径为 4-3-2-1。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Floyd</span><span class="params">(MGraph g, <span class="keyword">int</span> Path[][maxSize])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">int</span> A[maxSize][maxSize];</span><br><span class="line">    <span class="comment">// 这个双循环对数组 A[][]和 Path[][]进行了初始化</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g.n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; g.n; ++j) &#123;</span><br><span class="line">            A[i][j] = g.edges[i][j];</span><br><span class="line">            Path[i][j] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下面三层循环是主要操作，完成了以 k 为中间点对所有的顶点对 &#123;i, &#125; 进行检测和修改</span></span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; g.n; ++k) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g.n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; g.n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i][j] &gt; A[i][k] + A[k][j]) &#123;</span><br><span class="line">                    A[i][j] = A[i][k] + A[k][j];</span><br><span class="line">                    Path[i][j] = k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="18- 拓扑排序"><a href="#18- 拓扑排序" class="headerlink" title="18. 拓扑排序"></a>18. 拓扑排序</h2><h3 id="18-1）拓扑排序中对邻接表表头结构的修改"><a href="#18-1）拓扑排序中对邻接表表头结构的修改" class="headerlink" title="18.1）拓扑排序中对邻接表表头结构的修改"></a>18.1）拓扑排序中对邻接表表头结构的修改</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="keyword">int</span> count;  <span class="comment">// 此处为新增代码，count 用来统计顶点当前的入度</span></span><br><span class="line">    ArcNode *firstarc;</span><br><span class="line">&#125;VNode;</span><br></pre></td></tr></table></figure>

<h3 id="18-2）拓扑排序算法"><a href="#18-2）拓扑排序算法" class="headerlink" title="18.2）拓扑排序算法"></a>18.2）拓扑排序算法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TopSort</span><span class="params">(AGraph *G)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">stack</span>[maxSize], top = <span class="number">-1</span>;  <span class="comment">// 定义并初始化栈</span></span><br><span class="line">    ArcNode *p;</span><br><span class="line">    <span class="comment">// 这个循环将图中入度为 0 的顶点入栈</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;n; ++i) &#123;  <span class="comment">// 图中的顶点从 0 开始编号</span></span><br><span class="line">        <span class="keyword">if</span> (G-&gt;adjlist[i].count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">stack</span>[++top] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关键操作开始</span></span><br><span class="line">    <span class="keyword">while</span> (top != <span class="number">-1</span>) &#123;</span><br><span class="line">        i = <span class="built_in">stack</span>[top--];  <span class="comment">// 顶点出栈</span></span><br><span class="line">        ++n;  <span class="comment">// 计数器加 1，统计当前顶点</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 输出当前顶点</span></span><br><span class="line">        p = G-&gt;adjlist[i].firstarc;</span><br><span class="line">        <span class="comment">// 这个循环实现了将所有由此顶点引出的边所指向的顶点的入度都减少 1</span></span><br><span class="line">        <span class="comment">// 并将这个过程中入度变为 0 的顶点入栈</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">nullptr</span> != p) &#123;</span><br><span class="line">            j = p-&gt;adjvex;</span><br><span class="line">            --(G-&gt;adjlist[j].count);</span><br><span class="line">            <span class="keyword">if</span> (G-&gt;adjlist[j].count == <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">stack</span>[++top] = j;</span><br><span class="line">            p = p-&gt;nextarc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关键操作结束</span></span><br><span class="line">    <span class="keyword">return</span> n == G-&gt;n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="19- 排序算法"><a href="#19- 排序算法" class="headerlink" title="19. 排序算法"></a>19. 排序算法</h2><h3 id="19-1）直接插入排序"><a href="#19-1）直接插入排序" class="headerlink" title="19.1）直接插入排序"></a>19.1）直接插入排序</h3><p><img data-src="/archives/9ced5463/image-20211125181038341.png" alt="image-20211125181038341"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;<span class="comment">// 待排关键字存储在 A[]中，默认为整型，个数为 n</span></span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; i++)<span class="comment">// 依次将 A[2]～A[n]插入到前面已排序序列</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (A[i] &lt; A[i - <span class="number">1</span>]) &#123;<span class="comment">// 若当前元素小于其前驱，说明此时序列不满足递增的顺序，需要排序</span></span><br><span class="line">			A[<span class="number">0</span>] = A[i];<span class="comment">// 复制给哨兵</span></span><br><span class="line">			<span class="keyword">for</span> (j = i - <span class="number">1</span>; A[<span class="number">0</span>] &lt; A[j]; --j) &#123;<span class="comment">// 从后往前依次查找待插入的位置</span></span><br><span class="line">				A[j + <span class="number">1</span>] = A[j];<span class="comment">// 查一个，往后挪一个</span></span><br><span class="line">			&#125;</span><br><span class="line">			A[j + <span class="number">1</span>] = A[<span class="number">0</span>];<span class="comment">// 插入到正确位置</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="19-2）折半插入排序"><a href="#19-2）折半插入排序" class="headerlink" title="19.2）折半插入排序"></a>19.2）折半插入排序</h3><p><img data-src="/archives/9ced5463/image-20211125181230348.png" alt="image-20211125181230348"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, low, high, mid;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; i++) &#123;<span class="comment">// 依次将 A[2]～A[n]插入到前面已排序序列</span></span><br><span class="line">		A[<span class="number">0</span>] = A[i];<span class="comment">// 复制给哨兵</span></span><br><span class="line">		low = <span class="number">1</span>; high = i - <span class="number">1</span>;<span class="comment">// 设置折半查找的范围</span></span><br><span class="line">		<span class="keyword">while</span> (low &lt; high)<span class="comment">// 折半查找</span></span><br><span class="line">		&#123;</span><br><span class="line">			mid = (low + high) / <span class="number">2</span>;<span class="comment">// 取中间点</span></span><br><span class="line">			<span class="keyword">if</span> (A[mid] &gt; A[<span class="number">0</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				high = mid - <span class="number">1</span>;<span class="comment">// 查找左半子表</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				low = mid + <span class="number">1</span>;<span class="comment">// 查找右半子表</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (j = i - <span class="number">1</span>; j &gt;= high + <span class="number">1</span>; --j)</span><br><span class="line">		&#123;</span><br><span class="line">			A[j + <span class="number">1</span>] = A[j];<span class="comment">// 统一后移元素，空出插入位置</span></span><br><span class="line">		&#125;</span><br><span class="line">		A[high + <span class="number">1</span>] = A[<span class="number">0</span>];<span class="comment">// 插入</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//low=high 时，mid=low=high 这个时候就是最后一个需要比较的值 last</span></span><br><span class="line"><span class="comment">// 再一轮循环可以判断插入的位置是在 last 左边还是右边</span></span><br><span class="line"><span class="comment">// 假设是左边，high 就会到 last 左边一格去</span></span><br><span class="line"><span class="comment">// 假设是右边，low 就会到 last 右边去</span></span><br><span class="line"><span class="comment">// 无论哪一种情况，high+1 和 low-1 都可以表示插入的位置</span></span><br></pre></td></tr></table></figure>

<h3 id="19-3）希尔排序"><a href="#19-3）希尔排序" class="headerlink" title="19.3）希尔排序"></a>19.3）希尔排序</h3><p><img data-src="/archives/9ced5463/image-20211125181445471.png" alt="image-20211125181445471"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 希尔排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShellInsert</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, dk;</span><br><span class="line">	<span class="keyword">for</span> (dk = n / <span class="number">2</span>; dk &gt;= <span class="number">1</span>; dk = dk / <span class="number">2</span>)<span class="comment">// 步长变化</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 下面的内容就是把直接插入排序中所有的 1 改为 dk，一共有 6 处修改，别忘了 --j 也要改</span></span><br><span class="line">		<span class="keyword">for</span> (i = dk + <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (A[i] &lt; A[i - dk]) &#123;</span><br><span class="line">				A[<span class="number">0</span>] = A[i];</span><br><span class="line">				<span class="keyword">for</span> (j = i - dk; j &gt; <span class="number">0</span> &amp;&amp; A[<span class="number">0</span>] &lt; A[j]; j = j - dk) &#123;</span><br><span class="line">					A[j + dk] = A[j];</span><br><span class="line">				&#125;</span><br><span class="line">				A[j + dk] = A[<span class="number">0</span>];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="19-4）起泡排序"><a href="#19-4）起泡排序" class="headerlink" title="19.4）起泡排序"></a>19.4）起泡排序</h3><p><img data-src="/archives/9ced5463/image-20211125181538426.png" alt="image-20211125181538426"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, flag;<span class="comment">//i 用来指示“已沉底”元素，j 指示正在排序的元素</span></span><br><span class="line">	<span class="keyword">int</span> temp;</span><br><span class="line">	<span class="keyword">for</span> (i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i) &#123;<span class="comment">// 外层循环，每次沉底好一个，i 往前挪一个</span></span><br><span class="line">		flag = <span class="number">0</span>; <span class="comment">//flag 标记本趟排序是否发生了交换</span></span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= i; ++j) &#123;<span class="comment">// 一趟冒泡过程，从开始元素到沉底元素之间两两比较交换</span></span><br><span class="line">			<span class="keyword">if</span> (A[j - <span class="number">1</span>] &gt; A[j])</span><br><span class="line">			&#123;</span><br><span class="line">				temp = A[j];</span><br><span class="line">				A[j] = A[j - <span class="number">1</span>];</span><br><span class="line">				A[j - <span class="number">1</span>] = temp;</span><br><span class="line">				flag = <span class="number">1</span>;<span class="comment">// 本趟发生交换则 flag 置为 1</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="number">0</span>)<span class="comment">// 若一趟排序后没有发生交换，证明序列已经有序，排序结束</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="19-5）快速排序"><a href="#19-5）快速排序" class="headerlink" title="19.5）快速排序"></a>19.5）快速排序</h3><p><img data-src="/archives/9ced5463/image-20211125181738896.png" alt="image-20211125181738896"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (low &lt; high)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//Patition()就是划分操作，将表 A[low…high]划分为满足条件的两个子表</span></span><br><span class="line">		<span class="keyword">int</span> pivotpos = Partition(A, low, high);</span><br><span class="line">		QuickSort(A, low, pivotpos - <span class="number">1</span>);<span class="comment">// 依次对两个子表进行递归排序</span></span><br><span class="line">		QuickSort(A, pivotpos + <span class="number">1</span>, high);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;<span class="comment">// 一趟划分</span></span><br><span class="line">	<span class="keyword">int</span> pivot = A[low];<span class="comment">// 将当前表中的第一个元素设为枢纽，对表进行划分</span></span><br><span class="line">	<span class="keyword">while</span> (low &lt; high)<span class="comment">//low&lt;high 就是没有找到，只有 low 和 high 重合时，那此时就是中心位置</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (low &lt; high&amp;&amp;A[high] &gt;= pivot) --high;</span><br><span class="line">		A[low] = A[high];<span class="comment">// 将比枢纽小的元素搬到左端</span></span><br><span class="line">		<span class="keyword">while</span> (low &lt; high&amp;&amp;A[low] &lt;= pivot) ++low;</span><br><span class="line">		A[high] = A[low];<span class="comment">// 将比枢纽大的元素搬到右端</span></span><br><span class="line">		<span class="comment">// 里面这两个 while 要判断 low&lt;high</span></span><br><span class="line">		<span class="comment">// 因为搬动的过程 low 和 high 有移动，可能已经达到中心位置了</span></span><br><span class="line">	&#125;</span><br><span class="line">	A[low] = pivot;<span class="comment">// 枢纽元素存放在最终位置</span></span><br><span class="line">	<span class="keyword">return</span> low;<span class="comment">// 返回存放枢纽的最终位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="19-6）简单选择排序"><a href="#19-6）简单选择排序" class="headerlink" title="19.6）简单选择排序"></a>19.6）简单选择排序</h3><p><img data-src="/archives/9ced5463/image-20211125181840892.png" alt="image-20211125181840892"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SelecSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, j, min, temp;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;<span class="comment">// 一共进行 n-1 趟</span></span><br><span class="line">		min = i;<span class="comment">// 记录最小位置元素</span></span><br><span class="line">		<span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; n; j++)<span class="comment">// 从无序序列中挑出一个最小的元素</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (A[j] &lt; A[min]) min = j;<span class="comment">// 更新最小元素位置</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (min != i) <span class="comment">// 最小值不是本身交换</span></span><br><span class="line">			temp = A[i]; A[i] = A[min]; A[min] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="19-7）堆排序"><a href="#19-7）堆排序" class="headerlink" title="19.7）堆排序"></a>19.7）堆排序</h3><p><img data-src="/archives/9ced5463/image-20211125182032635.png" alt="image-20211125182032635"></p>
<h4 id="（19-7-1）创建堆与调整堆操作"><a href="#（19-7-1）创建堆与调整堆操作" class="headerlink" title="（19.7.1）创建堆与调整堆操作"></a>（19.7.1）创建堆与调整堆操作 </h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildMaxHeap</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 建立大根堆，叶子结点已经是堆，从第一个非叶子节点开始从下向上依次把结点调整为堆。</span></span><br><span class="line">	<span class="comment">// 完全二叉树最后一个叶子结点的双亲为 n/2; 所以从 i=[n/2]～１，反复调整堆</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		HeadAdjust(A, i, n);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeadAdjust</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> k, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//HeadAdjust 是将元素 k 为根的子树调整为堆。</span></span><br><span class="line">	<span class="comment">// 此时树中 A[k...n] 中记录的关键字除 A[k]之外均满足堆的定义 </span></span><br><span class="line">	<span class="comment">// 也就是说 A[k] 的左右孩子树都是堆，本函数调整 A[k]的关键字，使得 A[k...n]成为一个大根堆 </span></span><br><span class="line">	A[<span class="number">0</span>] = A[k];<span class="comment">//A[0] 暂存子树的根节点</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> * k; i &lt; n; i *= <span class="number">2</span>)<span class="comment">// 向下筛选 key 较大的子结点</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; n&amp;&amp;A[i] &lt; A[i + <span class="number">1</span>]) &#123;</span><br><span class="line">			i++;<span class="comment">// 取 key 较大的结点下标 i；默认 i 为左孩子，若右孩子更大，i+1</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (A[<span class="number">0</span>] &gt;= A[i]) &#123;<span class="comment">//key 值大的孩子与父结点比较，若满足大根堆，筛选结束；不满足互换位置接着向下筛</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			A[k] = A[i];<span class="comment">// 大结点与父结点互换</span></span><br><span class="line">			k = i;<span class="comment">// 修改 k 值，以便继续往下筛选</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	A[k] = A[<span class="number">0</span>];<span class="comment">// 被筛选结点的值放在最终位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（19-7-2）堆排序代码"><a href="#（19-7-2）堆排序代码" class="headerlink" title="（19.7.2）堆排序代码"></a>（19.7.2）堆排序代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HeapSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i, temp;</span><br><span class="line">	BuildMaxHeap(A, n);<span class="comment">// 初始建堆</span></span><br><span class="line">	<span class="keyword">for</span> (i = n; i &gt; <span class="number">1</span>; i--)<span class="comment">// 进行 n-1 趟交换与调整堆过程</span></span><br><span class="line">	&#123;</span><br><span class="line">		temp = A[<span class="number">1</span>];<span class="comment">// 输出堆顶元素（与堆底元素交换）</span></span><br><span class="line">		A[<span class="number">1</span>] = A[i];</span><br><span class="line">		A[i] = temp;</span><br><span class="line">		HeadAdjust(A, <span class="number">1</span>, i - <span class="number">1</span>);<span class="comment">// 调整，输出一次后把剩余的 i-1 个元素调整为堆</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="19-8）归并排序"><a href="#19-8）归并排序" class="headerlink" title="19.8）归并排序"></a>19.8）归并排序</h3><p><img data-src="/archives/9ced5463/image-20211125182138691.png" alt="image-20211125182138691"></p>
<h4 id="（19-8-1）-merge 操作"><a href="#（19-8-1）-merge 操作" class="headerlink" title="（19.8.1） merge 操作"></a>（19.8.1） merge 操作 </h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *B = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>((n + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">int</span>)); <span class="comment">// 辅助数组(动态存储)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 表 A 两段 A[low…mid] 和[mid+1…high]各自有序，将它们合并成一个有序表</span></span><br><span class="line">	<span class="keyword">int</span> i, j, k;</span><br><span class="line">	<span class="keyword">for</span> (k = low; k &lt;= high; k++)   <span class="comment">// 将 A 数组所有元素复制到 B 数组</span></span><br><span class="line">		B[k] = A[k];</span><br><span class="line">	<span class="keyword">for</span> (i = low, j = mid + <span class="number">1</span>, k = i; i &lt;= mid &amp;&amp; j &lt;= high; k++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (B[i] &lt;= B[j])<span class="comment">// 比较 B 中左右两段中元素</span></span><br><span class="line">			A[k] = B[i++];<span class="comment">// 将较小值复制给 A</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			A[k] = B[j++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= mid) A[k++] = B[i++];     <span class="comment">// 若左段没检测完，剩下的全接到 A 后面</span></span><br><span class="line">	<span class="keyword">while</span> (j &lt;= high) A[k++] = B[j++];    <span class="comment">// 若右段没检测完，剩下的全接到 A 后面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="（19-8-2）递归的归并排序算法"><a href="#（19-8-2）递归的归并排序算法" class="headerlink" title="（19.8.2）递归的归并排序算法"></a>（19.8.2）递归的归并排序算法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 归并排序函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">		<span class="keyword">int</span> mid = (high + low) / <span class="number">2</span>;<span class="comment">// 从中间划分两个子序列</span></span><br><span class="line">		MergeSort(A, low, mid);<span class="comment">// 对左侧子序列进行递归排序</span></span><br><span class="line">		MergeSort(A, mid + <span class="number">1</span>, high);<span class="comment">// 对右侧子序列进行递归排序</span></span><br><span class="line">		Merge(A, low, mid, high);<span class="comment">// 归并</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="19-9）基数排序（桶排序）"><a href="#19-9）基数排序（桶排序）" class="headerlink" title="19.9）基数排序（桶排序）"></a>19.9）基数排序（桶排序）</h3><p><img data-src="/archives/9ced5463/image-20211125182314634.png" alt="image-20211125182314634"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 了解</span></span><br></pre></td></tr></table></figure>



<h2 id="20- 查找算法"><a href="#20- 查找算法" class="headerlink" title="20. 查找算法"></a>20. 查找算法</h2><h3 id="20-1）顺序查找"><a href="#20-1）顺序查找" class="headerlink" title="20.1）顺序查找"></a>20.1）顺序查找</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 略</span></span><br></pre></td></tr></table></figure>

<h3 id="20-2）折半查找"><a href="#20-2）折半查找" class="headerlink" title="20.2）折半查找"></a>20.2）折半查找</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Bsearch</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        mid = (low+high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == k) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; k) &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="20-3）分块查找"><a href="#20-3）分块查找" class="headerlink" title="20.3）分块查找"></a>20.3）分块查找</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 了解</span></span><br></pre></td></tr></table></figure>

<h2 id="21- 二叉排序树（BST"><a href="#21- 二叉排序树（BST" class="headerlink" title="21. 二叉排序树（BST)"></a>21. 二叉排序树（BST)</h2><h3 id="21-1）二叉排序树的结点定义"><a href="#21-1）二叉排序树的结点定义" class="headerlink" title="21.1）二叉排序树的结点定义"></a>21.1）二叉排序树的结点定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> *<span class="title">lchild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BTNode;</span><br></pre></td></tr></table></figure>

<h3 id="21-2）二叉排序树的查找算法"><a href="#21-2）二叉排序树的查找算法" class="headerlink" title="21.2）二叉排序树的查找算法"></a>21.2）二叉排序树的查找算法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BTNode* <span class="title">BSTSearch</span><span class="params">(BTNode *bt, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bt == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;<span class="comment">// 来到了空指针域，查找不成功</span></span><br><span class="line">    <span class="keyword">if</span> (bt-&gt;key == key) &#123;</span><br><span class="line">        <span class="keyword">return</span> bt;<span class="comment">// 等于根结点中的关键字，查找成功，返回关键字所在结点指针</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; bt-&gt;key) &#123;<span class="comment">// 小于根结点中的关键字时到左子树中查找</span></span><br><span class="line">        <span class="keyword">return</span> BSTSearch(bt-&gt;lchild, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 大于根结点中的关键字时到右子树中查找</span></span><br><span class="line">        <span class="keyword">return</span> BSTSearch(bt-&gt;rchild, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="21-3）二叉排序树的插入算法"><a href="#21-3）二叉排序树的插入算法" class="headerlink" title="21.3）二叉排序树的插入算法"></a>21.3）二叉排序树的插入算法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BSTInsert</span><span class="params">(BTNode *&amp;bt, <span class="keyword">int</span> key)</span> </span>&#123;  <span class="comment">// 因为 bt 要改变，所以要用引用型指针</span></span><br><span class="line">    <span class="keyword">if</span> (bt == <span class="literal">nullptr</span>) &#123;<span class="comment">// 当前为空指针说明找到插入位置，创建新结点进行插入</span></span><br><span class="line">        bt = (BTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BTNode));  <span class="comment">// 创建新结点</span></span><br><span class="line">        bt-&gt;lchild = bt-&gt;rchild = <span class="literal">nullptr</span>;</span><br><span class="line">        bt-&gt;key = key;<span class="comment">// 将待插关键字存入新结点内，插入成功，返回 1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 如果结点不空则查找插入位置，与查找算法类似</span></span><br><span class="line">        <span class="keyword">if</span> (key == bt-&gt;key) <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">// 关键字已经存在于树中</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key &lt; bt-&gt;key) <span class="keyword">return</span> BSTInsert(bt-&gt;lchild, key);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> BSTInsert(bt-&gt;rchild, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="21-4）二叉排序树的构造算法"><a href="#21-4）二叉排序树的构造算法" class="headerlink" title="21.4）二叉排序树的构造算法"></a>21.4）二叉排序树的构造算法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateBST</span><span class="params">(BTNode *&amp;bt, <span class="keyword">int</span> key[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    bt = <span class="literal">nullptr</span>;  <span class="comment">// 将树清空</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;<span class="comment">// 调用插入函数，逐个插入关键字</span></span><br><span class="line">        BSTInsert(bt, key[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="22- 平衡二叉树 AVL"><a href="#22- 平衡二叉树 AVL" class="headerlink" title="22. 平衡二叉树 AVL"></a>22. 平衡二叉树 AVL</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 掌握思想</span></span><br></pre></td></tr></table></figure>


    </div>

    
    
    
      
  <div class="popular-posts-header">相关文章推荐</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\archives\608186a4.html" rel="bookmark">数据结构与算法概念题</a></div>
    </li>
  </ul>

        <div class="reward-container">
  <div>感谢各位打赏的小伙伴</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="肥肉啊肥肉你在哪 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="肥肉啊肥肉你在哪 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>肥肉啊肥肉你在哪
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://fat_fat_where_are_you.gitee.io/archives/9ced5463.html" title="考研数据结构代码整理">http://fat_fat_where_are_you.gitee.io/archives/9ced5463.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"><i class="fas fa-tags"></i> 数据结构</a>
          </div>

        
  <div class="post-widgets">
    <div class="wp_rating">
      <div id="wpac-rating"></div>
    </div>
  </div>


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/archives/fb4ff9cc.html" rel="prev" title="C 语言学习笔记 ( 上）">
      <i class="fa fa-chevron-left"></i> C 语言学习笔记 ( 上）
    </a></div>
      <div class="post-nav-item">
    <a href="/archives/13675369.html" rel="next" title="C 语言学习笔记（下）">
      C 语言学习笔记（下） <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%80%83%E7%A0%94%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%A3%E7%A0%81%E6%95%B4%E7%90%86"><span class="nav-text">考研数据结构代码整理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%20%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89"><span class="nav-text">1. 线性表的结构体定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1%EF%BC%89%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89"><span class="nav-text">1.1）顺序表的结构体定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2%EF%BC%89%E8%80%83%E8%AF%95%E4%B8%AD%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%AE%9A%E4%B9%89%E7%AE%80%E5%86%99%E6%B3%95"><span class="nav-text">1.2）考试中顺序表定义简写法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3%EF%BC%89%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89"><span class="nav-text">1.3）单链表的结构体定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4%EF%BC%89%E5%8F%8C%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89"><span class="nav-text">1.4）双链表结构体定义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%20%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-text">2. 顺序表的基本操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1%EF%BC%89%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%BA%E5%BA%8F%E8%A1%A8"><span class="nav-text">2.1）初始化顺序表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2%EF%BC%89%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%8C%89%E4%BD%8D%E6%9F%A5%E6%89%BE"><span class="nav-text">2.2）顺序表的按位查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3%EF%BC%89%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="nav-text">2.3）顺序表的插入操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4%EF%BC%89%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%8C%89%E5%80%BC%E6%9F%A5%E6%89%BE"><span class="nav-text">2.4）顺序表的按值查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5%EF%BC%89%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="nav-text">2.5）顺序表的删除操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6%EF%BC%89%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%B0%86%20-i-j-%20%E4%B8%AD%E5%85%83%E7%B4%A0%E9%80%86%E7%BD%AE"><span class="nav-text">2.6）顺序表将 [i:j] 中元素逆置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7%EF%BC%89%E5%88%A0%E9%99%A4%E4%B8%8B%E6%A0%87%E4%B8%BA%20i-j%20%E7%9A%84%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0"><span class="nav-text">2.7）删除下标为 i~j 的数据元素</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%20%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-text">3. 单链表的基本操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1%EF%BC%89%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="nav-text">3.1）初始化单链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2%EF%BC%89%E5%B0%BE%E6%8F%92%E6%B3%95%E5%BB%BA%E7%AB%8B%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="nav-text">3.2）尾插法建立单链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3%EF%BC%89%E5%A4%B4%E6%8F%92%E6%B3%95%E5%BB%BA%E7%AB%8B%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="nav-text">3.3）头插法建立单链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4%EF%BC%89%E5%BD%92%E5%B9%B6%E4%B8%A4%E5%8D%87%E5%BA%8F%E5%8D%95%E9%93%BE%E8%A1%A8%20A%E3%80%81B%20%E4%B8%BA%E5%8D%87%E5%BA%8F%20C%EF%BC%88%E5%B0%BE%E6%8F%92%E6%B3%95%EF%BC%89"><span class="nav-text">3.4）归并两升序单链表 A、B 为升序 C（尾插法）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5%EF%BC%89%E5%BD%92%E5%B9%B6%E4%B8%A4%E5%8D%87%E5%BA%8F%E5%8D%95%E9%93%BE%E8%A1%A8%20A%E3%80%81B%20%E4%B8%BA%E9%99%8D%E5%BA%8F%20C%EF%BC%88%E5%A4%B4%E6%8F%92%E6%B3%95%EF%BC%89"><span class="nav-text">3.5）归并两升序单链表 A、B 为降序 C（头插法）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6%EF%BC%89%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E5%B9%B6%E5%88%A0%E9%99%A4"><span class="nav-text">3.6）查找元素并删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7%EF%BC%89%E5%AF%B9%E4%BA%8E%E4%B8%80%E4%B8%AA%E9%80%92%E5%A2%9E%E5%8D%95%E9%93%BE%E8%A1%A8%EF%BC%8C%E5%88%A0%E9%99%A4%E5%85%B6%E9%87%8D%E5%A4%8D%E7%9A%84%E5%85%83%E7%B4%A0"><span class="nav-text">3.7）对于一个递增单链表，删除其重复的元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-8%EF%BC%89%E5%88%A0%E9%99%A4%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="nav-text">3.8）删除单链表中的最小值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-9%EF%BC%89%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8E%9F%E5%9C%B0%E9%80%86%E7%BD%AE"><span class="nav-text">3.9）单链表的原地逆置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-10%EF%BC%89%E5%B0%86%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%9F%9F%E4%B8%BA%E6%95%B4%E6%95%B0%E7%9A%84%E5%8D%95%E9%93%BE%E8%A1%A8%E5%88%86%E5%89%B2%E4%B8%BA%E4%B8%A4%E4%B8%AA%E5%88%86%E5%88%AB%E4%B8%BA%E5%A5%87%E6%95%B0%E5%92%8C%E5%81%B6%E6%95%B0%E7%9A%84%E9%93%BE%E8%A1%A8"><span class="nav-text">3.10）将一个数据域为整数的单链表分割为两个分别为奇数和偶数的链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-11%EF%BC%89%E9%80%86%E5%BA%8F%E6%89%93%E5%8D%B0%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-text">3.11）逆序打印单链表中的节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-12%EF%BC%89%E6%9F%A5%E6%89%BE%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%AC%20k%20%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="nav-text">3.12）查找链表中倒数第 k 个节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-13%EF%BC%89%E5%B0%86%E4%B8%A4%E4%B8%AA%E5%8D%87%E5%BA%8F%E5%8D%95%E9%93%BE%E8%A1%A8%20A%E3%80%81B%20%E6%B1%82%E5%B7%AE%E9%9B%86%20A-B%20%E5%AD%98%E5%85%A5%20A%20%E4%B8%AD"><span class="nav-text">3.13）将两个升序单链表 A、B 求差集 A-B 存入 A 中</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%20%E5%8F%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-text">4. 双链表的基本操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1%EF%BC%89%E5%B0%BE%E6%8F%92%E6%B3%95%E5%BB%BA%E7%AB%8B%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="nav-text">4.1）尾插法建立双链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2%EF%BC%89%E5%8F%8C%E9%93%BE%E8%A1%A8%E6%9F%A5%E6%89%BE%E7%BB%93%E7%82%B9"><span class="nav-text">4.2）双链表查找结点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3%EF%BC%89%E5%8F%8C%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E7%BB%93%E7%82%B9"><span class="nav-text">4.3）双链表插入结点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4%EF%BC%89%E5%8F%8C%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5%E5%88%A0%E9%99%A4"><span class="nav-text">4.4）双链表插入删除</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%20%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89"><span class="nav-text">5. 栈和队列的结构体定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1%EF%BC%89%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">5.1）顺序栈的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2%EF%BC%89%E9%93%BE%E6%A0%88%E7%BB%93%E7%82%B9%E5%AE%9A%E4%B9%89"><span class="nav-text">5.2）链栈结点定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3%EF%BC%89%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-text">5.3）顺序队列的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4%EF%BC%89%E9%93%BE%E9%98%9F%E5%AE%9A%E4%B9%89"><span class="nav-text">5.4）链队定义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%885-4-1%EF%BC%89%E9%98%9F%E7%BB%93%E7%82%B9%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="nav-text">（5.4.1）队结点类型定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%885-4-2%EF%BC%89%E9%93%BE%E9%98%9F%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="nav-text">（5.4.2）链队类型定义</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%20%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-text">6. 顺序栈的基本操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1%EF%BC%89%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">6.1）顺序栈的初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2%EF%BC%89%E5%88%A4%E6%96%AD%E6%A0%88%E7%A9%BA%E6%A0%88%E6%BB%A1"><span class="nav-text">6.2）判断栈空栈满</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3%EF%BC%89%E8%BF%9B%E6%A0%88%E4%BB%A3%E7%A0%81"><span class="nav-text">6.3）进栈代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4%EF%BC%89%E5%87%BA%E6%A0%88%E4%BB%A3%E7%A0%81"><span class="nav-text">6.4）出栈代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5%EF%BC%89%E8%80%83%E8%AF%95%E4%B8%AD%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%94%A8%E6%B3%95%E7%9A%84%E7%AE%80%E6%B4%81%E5%86%99%E6%B3%95"><span class="nav-text">6.5）考试中顺序栈用法的简洁写法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%20%E9%93%BE%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-text">7. 链栈的基本操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1%EF%BC%89%E9%93%BE%E6%A0%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">7.1）链栈的初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2%EF%BC%89%E5%88%A4%E6%96%AD%E6%A0%88%E7%A9%BA"><span class="nav-text">7.2）判断栈空</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3%EF%BC%89%E8%BF%9B%E6%A0%88%E4%BB%A3%E7%A0%81"><span class="nav-text">7.3）进栈代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4%EF%BC%89%E5%87%BA%E6%A0%88%E4%BB%A3%E7%A0%81"><span class="nav-text">7.4）出栈代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%20%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-text">8. 顺序队列的基本操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1%EF%BC%89%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">8.1）顺序队列的初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2%EF%BC%89%E5%88%A4%E6%96%AD%E9%98%9F%E7%A9%BA%E9%98%9F%E6%BB%A1"><span class="nav-text">8.2）判断队空队满</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3%EF%BC%89%E8%BF%9B%E9%98%9F%E7%AE%97%E6%B3%95"><span class="nav-text">8.3）进队算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-4%EF%BC%89%E5%87%BA%E9%98%9F%E7%AE%97%E6%B3%95"><span class="nav-text">8.4）出队算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%20%E9%93%BE%E9%98%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-text">9. 链队的基本操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-1%EF%BC%89%E9%93%BE%E9%98%9F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">9.1）链队的初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2%EF%BC%89%E5%88%A4%E6%96%AD%E9%98%9F%E7%A9%BA%E7%AE%97%E6%B3%95"><span class="nav-text">9.2）判断队空算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-3%EF%BC%89%E5%85%A5%E9%98%9F%E7%AE%97%E6%B3%95"><span class="nav-text">9.3）入队算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-4%EF%BC%89%E5%87%BA%E9%98%9F%E7%AE%97%E6%B3%95"><span class="nav-text">9.4）出队算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-%20%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-text">10. 栈的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#10-1%EF%BC%89%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98"><span class="nav-text">10.1）括号匹配问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2%EF%BC%89%E8%AE%A1%E7%AE%97%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">10.2）计算后缀表达式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-%20%E6%95%B0%E7%BB%84"><span class="nav-text">11. 数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%93%E7%82%B9%E5%AE%9A%E4%B9%89"><span class="nav-text">12. 二叉树的结点定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#12-1%EF%BC%89%E6%99%AE%E9%80%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E7%82%B9%E5%AE%9A%E4%B9%89"><span class="nav-text">12.1）普通二叉树的链式存储结点定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-2%EF%BC%89%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%93%E7%82%B9%E5%AE%9A%E4%B9%89"><span class="nav-text">12.2）线索二叉树的结点定义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-text">13. 二叉树的操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#13-1%EF%BC%89%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E9%80%92%E5%BD%92%EF%BC%89"><span class="nav-text">13.1）先序遍历（递归）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-2%EF%BC%89%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E9%80%92%E5%BD%92%EF%BC%89"><span class="nav-text">13.2）中序遍历（递归）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-3%EF%BC%89%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E9%80%92%E5%BD%92%EF%BC%89"><span class="nav-text">13.3）后序遍历（递归）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-4%EF%BC%89%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-text">13.4）层序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-5%EF%BC%89%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E9%9D%9E%E9%80%92%E5%BD%92%EF%BC%89"><span class="nav-text">13.5）先序遍历（非递归）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-6%EF%BC%89%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E9%9D%9E%E9%80%92%E5%BD%92%EF%BC%89"><span class="nav-text">13.6）中序遍历（非递归）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-7%EF%BC%89%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E9%9D%9E%E9%80%92%E5%BD%92%EF%BC%89"><span class="nav-text">13.7）后序遍历（非递归）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-8%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E5%8C%96"><span class="nav-text">13.8）二叉树中序线索化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-9%EF%BC%89%E9%80%9A%E8%BF%87%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BB%BA%E7%AB%8B%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">13.9）通过中序遍历建立中序线索二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-10%EF%BC%89%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-text">13.10）中序线索二叉树的遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-11%EF%BC%89%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B7%B1%E5%BA%A6"><span class="nav-text">13.11）求二叉树深度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-12%EF%BC%89%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AE%BD%E5%BA%A6%EF%BC%88%E8%80%83%E8%BF%87%EF%BC%89"><span class="nav-text">13.12）求二叉树宽度（考过）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-13%EF%BC%89%E6%9F%A5%E6%89%BE%E6%8C%87%E5%AE%9A%E5%80%BC%20key"><span class="nav-text">13.13）查找指定值 key</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-14%EF%BC%89%E6%9F%A5%E6%89%BE%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E4%B8%AD%E7%AC%AC%20k%20%E4%B8%AA%E5%80%BC"><span class="nav-text">13.14）查找前中后序中第 k 个值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-15%EF%BC%89%E8%BE%93%E5%87%BA%E6%A0%B9%E7%BB%93%E7%82%B9%E5%88%B0%E6%AF%8F%E4%B8%AA%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="nav-text">13.15）输出根结点到每个叶子结点的路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-16%EF%BC%89%E8%AE%A1%E7%AE%97%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BD%A2%E5%BC%8F%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%80%BC"><span class="nav-text">13.16）计算二叉树形式的表达式的值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-17%EF%BC%89%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="nav-text">13.17）哈夫曼编码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-%20%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">14. 图的存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#14-1%EF%BC%89%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E7%9A%84%E7%BB%93%E7%82%B9%E5%AE%9A%E4%B9%89"><span class="nav-text">14.1）邻接矩阵的结点定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-2%EF%BC%89%E9%82%BB%E6%8E%A5%E8%A1%A8%E7%9A%84%E7%BB%93%E7%82%B9%E5%AE%9A%E4%B9%89"><span class="nav-text">14.2）邻接表的结点定义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-%20%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%E4%B8%8E%E5%BA%94%E7%94%A8"><span class="nav-text">15. 图的遍历与应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#15-1%EF%BC%89%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%20DFS"><span class="nav-text">15.1）图的深度优先遍历 DFS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-2%EF%BC%89%E5%9B%BE%E7%9A%84%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%20BFS"><span class="nav-text">15.2）图的广度优先遍历 BFS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-3%EF%BC%89%E6%B1%82%E4%B8%8D%E5%B8%A6%E6%9D%83%E8%BF%9E%E9%80%9A%E5%9B%BE%E4%B8%AD%E8%B7%9D%E7%82%B9%20v%20%E6%9C%80%E8%BF%9C%E7%82%B9"><span class="nav-text">15.3）求不带权连通图中距点 v 最远点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-4%EF%BC%89%E5%88%A4%E6%96%AD%E6%97%A0%E5%90%91%E5%9B%BE%E6%98%AF%E5%90%A6%E4%B8%BA%E4%B8%80%E6%A3%B5%E6%A0%91"><span class="nav-text">15.4）判断无向图是否为一棵树 </span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-5%EF%BC%89%E5%88%86%E5%88%AB%E7%94%A8%20BFS%E3%80%81DFS%20%E5%88%A4%E6%96%AD%E5%9B%BE%E4%B8%AD%E7%82%B9%20i%E3%80%81j%20%E6%98%AF%E5%90%A6%E8%BF%9E%E9%80%9A"><span class="nav-text">15.5）分别用 BFS、DFS 判断图中点 i、j 是否连通 </span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-6%EF%BC%89%E5%88%A4%E6%96%AD%E6%9C%89%E5%90%91%E5%9B%BE%20G%20%E6%98%AF%E5%90%A6%E6%9C%89%E6%A0%B9"><span class="nav-text">15.6）判断有向图 G 是否有根</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-%20%E6%9C%80%E5%B0%8F%EF%BC%88%E4%BB%A3%E4%BB%B7%EF%BC%89%E7%94%9F%E6%88%90%E6%A0%91"><span class="nav-text">16. 最小（代价）生成树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#16-1%EF%BC%89Prim%20%E7%AE%97%E6%B3%95"><span class="nav-text">16.1）Prim 算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-2%EF%BC%89Kruskal%20%E7%AE%97%E6%B3%95"><span class="nav-text">16.2）Kruskal 算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-%20%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95"><span class="nav-text">17. 最短路径算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#17-1%EF%BC%89Dijkstra%20%E7%AE%97%E6%B3%95"><span class="nav-text">17.1）Dijkstra 算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-2%EF%BC%89Floyd%20%E7%AE%97%E6%B3%95"><span class="nav-text">17.2）Floyd 算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18-%20%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="nav-text">18. 拓扑排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#18-1%EF%BC%89%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E4%B8%AD%E5%AF%B9%E9%82%BB%E6%8E%A5%E8%A1%A8%E8%A1%A8%E5%A4%B4%E7%BB%93%E6%9E%84%E7%9A%84%E4%BF%AE%E6%94%B9"><span class="nav-text">18.1）拓扑排序中对邻接表表头结构的修改</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-2%EF%BC%89%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-text">18.2）拓扑排序算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-text">19. 排序算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#19-1%EF%BC%89%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-text">19.1）直接插入排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-2%EF%BC%89%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-text">19.2）折半插入排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-3%EF%BC%89%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="nav-text">19.3）希尔排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-4%EF%BC%89%E8%B5%B7%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="nav-text">19.4）起泡排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-5%EF%BC%89%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-text">19.5）快速排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-6%EF%BC%89%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-text">19.6）简单选择排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-7%EF%BC%89%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="nav-text">19.7）堆排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8819-7-1%EF%BC%89%E5%88%9B%E5%BB%BA%E5%A0%86%E4%B8%8E%E8%B0%83%E6%95%B4%E5%A0%86%E6%93%8D%E4%BD%9C"><span class="nav-text">（19.7.1）创建堆与调整堆操作 </span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8819-7-2%EF%BC%89%E5%A0%86%E6%8E%92%E5%BA%8F%E4%BB%A3%E7%A0%81"><span class="nav-text">（19.7.2）堆排序代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-8%EF%BC%89%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-text">19.8）归并排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8819-8-1%EF%BC%89-merge%20%E6%93%8D%E4%BD%9C"><span class="nav-text">（19.8.1） merge 操作 </span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%EF%BC%8819-8-2%EF%BC%89%E9%80%92%E5%BD%92%E7%9A%84%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-text">（19.8.2）递归的归并排序算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-9%EF%BC%89%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F%EF%BC%88%E6%A1%B6%E6%8E%92%E5%BA%8F%EF%BC%89"><span class="nav-text">19.9）基数排序（桶排序）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-%20%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="nav-text">20. 查找算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#20-1%EF%BC%89%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE"><span class="nav-text">20.1）顺序查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-2%EF%BC%89%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE"><span class="nav-text">20.2）折半查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#20-3%EF%BC%89%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE"><span class="nav-text">20.3）分块查找</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-%20%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%EF%BC%88BST"><span class="nav-text">21. 二叉排序树（BST)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#21-1%EF%BC%89%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E7%BB%93%E7%82%B9%E5%AE%9A%E4%B9%89"><span class="nav-text">21.1）二叉排序树的结点定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-2%EF%BC%89%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="nav-text">21.2）二叉排序树的查找算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-3%EF%BC%89%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%E7%AE%97%E6%B3%95"><span class="nav-text">21.3）二叉排序树的插入算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-4%EF%BC%89%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0%E7%AE%97%E6%B3%95"><span class="nav-text">21.4）二叉排序树的构造算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#22-%20%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%20AVL"><span class="nav-text">22. 平衡二叉树 AVL</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="肥肉啊肥肉你在哪" src="/images/touxiang.gif">
  <p class="site-author-name" itemprop="name">肥肉啊肥肉你在哪</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">35</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/feirouafeirou" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;feirouafeirou" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://wpa.qq.com/msgrd?v=3&uin=1729013657&site=qq&menu=yes" title="QQ → http:&#x2F;&#x2F;wpa.qq.com&#x2F;msgrd?v&#x3D;3&amp;uin&#x3D;1729013657&amp;site&#x3D;qq&amp;menu&#x3D;yes" rel="external nofollow noopener noreferrer" target="_blank"><i class="fab fa-qq fa-fw"></i>QQ</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      友情链接
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://www.woshipm.com/" title="http:&#x2F;&#x2F;www.woshipm.com" rel="external nofollow noopener noreferrer" target="_blank">人人都是产品经理</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.chanpin100.com/" title="http:&#x2F;&#x2F;www.chanpin100.com" rel="external nofollow noopener noreferrer" target="_blank">产品壹佰</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>

  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">肥肉啊肥肉你在哪</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">208k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:09</span>
</div>

<div class="translate-style">
繁/简：<a id="translateLink" href="javascript:translatePage();">繁体
</a>
</div>
<script type="text/javascript" src="/js/tw_cn.js"></script>
<script type="text/javascript">
var defaultEncoding = 2; //网站编写字体是否繁体，1-繁体，2-简体
var translateDelay = 0; //延迟时间,若不在前, 要设定延迟翻译时间, 如100表示100ms,默认为0
var cookieDomain = "https://feirouafeirou.github.io/"; //Cookie地址, 一定要设定, 通常为你的网址
var msgToTraditionalChinese = "繁体"; //此处可以更改为你想要显示的文字
var msgToSimplifiedChinese = "简体"; //同上，但两处均不建议更改
var translateButtonId = "translateLink"; //默认互换id
translateInitilization();
</script>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>


  



  <script>
  if (CONFIG.page.isPost) {
    wpac_init = window.wpac_init || [];
    wpac_init.push({
      widget: 'Rating',
      id    : 26171,
      el    : 'wpac-rating',
      color : 'fc6423'
    });
    (function() {
      if ('WIDGETPACK_LOADED' in window) return;
      WIDGETPACK_LOADED = true;
      var mc = document.createElement('script');
      mc.type = 'text/javascript';
      mc.async = true;
      mc.src = '//embed.widgetpack.com/widget.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(mc, s.nextSibling);
    })();
  }
  </script>

  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'puzQn5yHhkbtBj2VGFbqJ4FE-MdYXbMMI',
      appKey     : 'lmcgKM2surcxNxMRiqInHjkU',
      placeholder: "Just go go",
      avatar     : 'retro',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>
<div class="moon-menu">
  <div class="moon-menu-items">
    
    <div id="moon-menu-item-back2bottom" class="moon-menu-item" onclick="back2bottom()">
      <i class="fa fa-chevron-down"></i>    </div>
    
    <div id="moon-menu-item-back2top" class="moon-menu-item" onclick="back2top()">
      <i class="fa fa-chevron-up"></i>    </div>
    
  </div>
  <div class="moon-menu-button">
    <svg class="moon-menu-bg">
      <circle class="moon-menu-cricle" cx="50%" cy="50%" r="44%"/>
      <circle class="moon-menu-border" cx="50%" cy="50%" r="48%"/>
    </svg>
    <div class="moon-menu-content">
      <div class="moon-menu-icon"><i class="fas fa-ellipsis-v"></i></div>
      <div class="moon-menu-text"></div>
    </div>
  </div>
</div><script src="/js/injector.js"></script>
<!-- 数字雨 -->
<!-- <canvas id="canvas" width="1440" height="900" ></canvas> -->
<!-- <script type="text/javascript" src="/js/src/DigitalRain.js"></script> -->
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
<!--浏览器搞笑标题-->
<script type="text/javascript" src="/js/FunnyTitle.js"></script>
<!-- Live2D看板娘 -->
<!-- <script src="/live2d-widget/autoload.js"></script> -->
<!-- <script src="https://feirouafeirou.github.io/live2d-widget/autoload.js"></script> -->
<!-- 网页音乐播放器 -->
<!-- <link rel="stylesheet" href="/dist/APlayer.min.css">
<div id="aplayer"></div>
<script type="text/javascript" src="/dist/APlayer.min.js"></script>
<script type="text/javascript" src="/dist/music.js"></script> -->
</body>

</html>
